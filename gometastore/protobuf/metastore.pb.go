// Code generated by protoc-gen-go. DO NOT EDIT.
// source: metastore.proto

/*
Package metastore is a generated protocol buffer package.

It is generated from these files:
	metastore.proto

It has these top-level messages:
	RequestStatus
	Id
	Database
	CreateDatabaseRequest
	AlterDatabaseRequest
	GetDatabaseRequest
	GetDatabaseResponse
	ListDatabasesRequest
	DropDatabaseRequest
	FieldSchema
	SerDeInfo
	Order
	StorageDescriptor
	Table
	CreateTableRequest
	GetTableRequest
	GetTableResponse
	ListTablesRequest
	DropTableRequest
	Partition
	AddPartitionRequest
	GetPartitionRequest
	GetPartitionResponse
	ListPartitionsRequest
	DropPartitionRequest
*/
package metastore

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger/options"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Known SerDes are represented using enum. Unknown ones are represented using strings.
type SerdeType int32

const (
	SerdeType_SERDE_CUSTOM      SerdeType = 0
	SerdeType_SERDE_LAZY_SIMPLE SerdeType = 1
	SerdeType_SERDE_AVRO        SerdeType = 2
	SerdeType_SERDE_JSON        SerdeType = 3
	SerdeType_SERDE_ORC         SerdeType = 4
	SerdeType_SERDE_REGEX       SerdeType = 5
	SerdeType_SERDE_THRIFT      SerdeType = 6
	SerdeType_SERDE_PARQUET     SerdeType = 7
	SerdeType_SERDE_CSV         SerdeType = 8
)

var SerdeType_name = map[int32]string{
	0: "SERDE_CUSTOM",
	1: "SERDE_LAZY_SIMPLE",
	2: "SERDE_AVRO",
	3: "SERDE_JSON",
	4: "SERDE_ORC",
	5: "SERDE_REGEX",
	6: "SERDE_THRIFT",
	7: "SERDE_PARQUET",
	8: "SERDE_CSV",
}
var SerdeType_value = map[string]int32{
	"SERDE_CUSTOM":      0,
	"SERDE_LAZY_SIMPLE": 1,
	"SERDE_AVRO":        2,
	"SERDE_JSON":        3,
	"SERDE_ORC":         4,
	"SERDE_REGEX":       5,
	"SERDE_THRIFT":      6,
	"SERDE_PARQUET":     7,
	"SERDE_CSV":         8,
}

func (x SerdeType) String() string {
	return proto.EnumName(SerdeType_name, int32(x))
}
func (SerdeType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Known Input Formats. CUSTOM means that it should be specified as a string.
type InputFormat int32

const (
	InputFormat_IF_CUSTOM   InputFormat = 0
	InputFormat_IF_SEQUENCE InputFormat = 1
	InputFormat_IF_TEXT     InputFormat = 2
	InputFormat_IF_HIVE     InputFormat = 3
)

var InputFormat_name = map[int32]string{
	0: "IF_CUSTOM",
	1: "IF_SEQUENCE",
	2: "IF_TEXT",
	3: "IF_HIVE",
}
var InputFormat_value = map[string]int32{
	"IF_CUSTOM":   0,
	"IF_SEQUENCE": 1,
	"IF_TEXT":     2,
	"IF_HIVE":     3,
}

func (x InputFormat) String() string {
	return proto.EnumName(InputFormat_name, int32(x))
}
func (InputFormat) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// Known Output Formats. CUSTOM means that it should be specified as a string.
//
// Here is a list of known output formats:
//
// - org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat
// - org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat
// - org.apache.hadoop.hive.ql.io.HiveNullValueSequenceFileOutputFormat
// - org.apache.hadoop.hive.ql.io.HivePassThroughOutputFormat
// - org.apache.hadoop.hive.ql.io.IgnoreKeyTextOutputFormat
// - org.apache.hadoop.hive.ql.io.HiveBinaryOutputFormat
// - org.apache.hadoop.hive.ql.io.RCFileOutputFormat
//
type OutputFormat int32

const (
	OutputFormat_OF_CUSTOM     OutputFormat = 0
	OutputFormat_OF_SEQUENCE   OutputFormat = 2
	OutputFormat_OF_IGNORE_KEY OutputFormat = 3
	OutputFormat_OF_HIVE       OutputFormat = 4
)

var OutputFormat_name = map[int32]string{
	0: "OF_CUSTOM",
	2: "OF_SEQUENCE",
	3: "OF_IGNORE_KEY",
	4: "OF_HIVE",
}
var OutputFormat_value = map[string]int32{
	"OF_CUSTOM":     0,
	"OF_SEQUENCE":   2,
	"OF_IGNORE_KEY": 3,
	"OF_HIVE":       4,
}

func (x OutputFormat) String() string {
	return proto.EnumName(OutputFormat_name, int32(x))
}
func (OutputFormat) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type TableType int32

const (
	TableType_TTYPE_MANAGED  TableType = 0
	TableType_TTYPE_EXTERNAL TableType = 1
	TableType_TTYPE_INDEX    TableType = 2
)

var TableType_name = map[int32]string{
	0: "TTYPE_MANAGED",
	1: "TTYPE_EXTERNAL",
	2: "TTYPE_INDEX",
}
var TableType_value = map[string]int32{
	"TTYPE_MANAGED":  0,
	"TTYPE_EXTERNAL": 1,
	"TTYPE_INDEX":    2,
}

func (x TableType) String() string {
	return proto.EnumName(TableType_name, int32(x))
}
func (TableType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type SerializationLib int32

const (
	SerializationLib_SL_CUSTOM      SerializationLib = 0
	SerializationLib_SL_LAZY_SIMPLE SerializationLib = 1
)

var SerializationLib_name = map[int32]string{
	0: "SL_CUSTOM",
	1: "SL_LAZY_SIMPLE",
}
var SerializationLib_value = map[string]int32{
	"SL_CUSTOM":      0,
	"SL_LAZY_SIMPLE": 1,
}

func (x SerializationLib) String() string {
	return proto.EnumName(SerializationLib_name, int32(x))
}
func (SerializationLib) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type RequestStatus_Status int32

const (
	RequestStatus_STATUS_OK           RequestStatus_Status = 0
	RequestStatus_STATUS_ERROR        RequestStatus_Status = 1
	RequestStatus_STATUS_NOTFOUND     RequestStatus_Status = 2
	RequestStatus_STATUS_CONFLICT     RequestStatus_Status = 3
	RequestStatus_STATUS_BUSY         RequestStatus_Status = 4
	RequestStatus_STATUS_INTERNAL_ERR RequestStatus_Status = 5
)

var RequestStatus_Status_name = map[int32]string{
	0: "STATUS_OK",
	1: "STATUS_ERROR",
	2: "STATUS_NOTFOUND",
	3: "STATUS_CONFLICT",
	4: "STATUS_BUSY",
	5: "STATUS_INTERNAL_ERR",
}
var RequestStatus_Status_value = map[string]int32{
	"STATUS_OK":           0,
	"STATUS_ERROR":        1,
	"STATUS_NOTFOUND":     2,
	"STATUS_CONFLICT":     3,
	"STATUS_BUSY":         4,
	"STATUS_INTERNAL_ERR": 5,
}

func (x RequestStatus_Status) String() string {
	return proto.EnumName(RequestStatus_Status_name, int32(x))
}
func (RequestStatus_Status) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

// General status for results.
//
// All non-streaming requests should return RequestStatus.
type RequestStatus struct {
	Status RequestStatus_Status `protobuf:"varint,1,opt,name=status,enum=metastore.RequestStatus_Status" json:"status,omitempty"`
	Error  string               `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
}

func (m *RequestStatus) Reset()                    { *m = RequestStatus{} }
func (m *RequestStatus) String() string            { return proto.CompactTextString(m) }
func (*RequestStatus) ProtoMessage()               {}
func (*RequestStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *RequestStatus) GetStatus() RequestStatus_Status {
	if m != nil {
		return m.Status
	}
	return RequestStatus_STATUS_OK
}

func (m *RequestStatus) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

// Objects have unique name and unique ID.
//
// Name of the object can change but ID never changes. This allows caching of objects
// by ID.
// Both name and ID are just sequence of bytes - there are no
// assumptions about encoding or length.
// Implementations may enforce specific assumptions.
type Id struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Id   string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
}

func (m *Id) Reset()                    { *m = Id{} }
func (m *Id) String() string            { return proto.CompactTextString(m) }
func (*Id) ProtoMessage()               {}
func (*Id) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Id) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Id) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// Database is a container for tables.
//
// Database object has two sets of parameters:
//  - User parameters are intended for user and are just transparently passed around
//  - System parameters are intended to be used by Hive for its internal purposes
//
// Database has two IDs:
// - Id.id is assigned during database creation and it is a unique and stable ID. WHile database
//   name can change, the id can't, so clients can cache Database by ID.
// - seq_id is assigned during database creation. It should be a unique ID within the catalog.
//   The intention is having an incrementing integer value for each new database. It is not
//   guaranteed to be monotonous.
//
// Original Metastore Database object also had owner information.
// These can be represented using system parameters if needed since the current
// metastore service does not interpret Owner info.
type Database struct {
	Id               *Id               `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	SeqId            uint64            `protobuf:"varint,2,opt,name=seq_id,json=seqId" json:"seq_id,omitempty"`
	Location         string            `protobuf:"bytes,3,opt,name=location" json:"location,omitempty"`
	Parameters       map[string]string `protobuf:"bytes,4,rep,name=parameters" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	SystemParameters map[string]string `protobuf:"bytes,5,rep,name=system_parameters,json=systemParameters" json:"system_parameters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Database) Reset()                    { *m = Database{} }
func (m *Database) String() string            { return proto.CompactTextString(m) }
func (*Database) ProtoMessage()               {}
func (*Database) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Database) GetId() *Id {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Database) GetSeqId() uint64 {
	if m != nil {
		return m.SeqId
	}
	return 0
}

func (m *Database) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func (m *Database) GetParameters() map[string]string {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *Database) GetSystemParameters() map[string]string {
	if m != nil {
		return m.SystemParameters
	}
	return nil
}

// Create a new database.
//
// If database.Id.id is empty, it will be assigned a unique ID
// database.seq_id is assigned when database is created
type CreateDatabaseRequest struct {
	Catalog  string    `protobuf:"bytes,1,opt,name=catalog" json:"catalog,omitempty"`
	Database *Database `protobuf:"bytes,2,opt,name=database" json:"database,omitempty"`
	Cookie   string    `protobuf:"bytes,3,opt,name=cookie" json:"cookie,omitempty"`
}

func (m *CreateDatabaseRequest) Reset()                    { *m = CreateDatabaseRequest{} }
func (m *CreateDatabaseRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateDatabaseRequest) ProtoMessage()               {}
func (*CreateDatabaseRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *CreateDatabaseRequest) GetCatalog() string {
	if m != nil {
		return m.Catalog
	}
	return ""
}

func (m *CreateDatabaseRequest) GetDatabase() *Database {
	if m != nil {
		return m.Database
	}
	return nil
}

func (m *CreateDatabaseRequest) GetCookie() string {
	if m != nil {
		return m.Cookie
	}
	return ""
}

// Alter database
type AlterDatabaseRequest struct {
	Catalog  string    `protobuf:"bytes,1,opt,name=catalog" json:"catalog,omitempty"`
	Id       *Id       `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	Database *Database `protobuf:"bytes,3,opt,name=database" json:"database,omitempty"`
	Cookie   string    `protobuf:"bytes,4,opt,name=cookie" json:"cookie,omitempty"`
}

func (m *AlterDatabaseRequest) Reset()                    { *m = AlterDatabaseRequest{} }
func (m *AlterDatabaseRequest) String() string            { return proto.CompactTextString(m) }
func (*AlterDatabaseRequest) ProtoMessage()               {}
func (*AlterDatabaseRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *AlterDatabaseRequest) GetCatalog() string {
	if m != nil {
		return m.Catalog
	}
	return ""
}

func (m *AlterDatabaseRequest) GetId() *Id {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *AlterDatabaseRequest) GetDatabase() *Database {
	if m != nil {
		return m.Database
	}
	return nil
}

func (m *AlterDatabaseRequest) GetCookie() string {
	if m != nil {
		return m.Cookie
	}
	return ""
}

// Request to get database by its ID.
//
// Database can be located by either part of the ID. If id.id is specified, it will be used first,
// otherwise iid.name is used. One of these must be specified.
type GetDatabaseRequest struct {
	Catalog string `protobuf:"bytes,1,opt,name=catalog" json:"catalog,omitempty"`
	Id      *Id    `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	Cookie  string `protobuf:"bytes,3,opt,name=cookie" json:"cookie,omitempty"`
}

func (m *GetDatabaseRequest) Reset()                    { *m = GetDatabaseRequest{} }
func (m *GetDatabaseRequest) String() string            { return proto.CompactTextString(m) }
func (*GetDatabaseRequest) ProtoMessage()               {}
func (*GetDatabaseRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *GetDatabaseRequest) GetCatalog() string {
	if m != nil {
		return m.Catalog
	}
	return ""
}

func (m *GetDatabaseRequest) GetId() *Id {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *GetDatabaseRequest) GetCookie() string {
	if m != nil {
		return m.Cookie
	}
	return ""
}

// Result of GetDatabase request
//
// The result consists of the database information (which may be empty in case of failure)
// and request status.
// TODO: specify error cases
type GetDatabaseResponse struct {
	Database *Database      `protobuf:"bytes,1,opt,name=database" json:"database,omitempty"`
	Status   *RequestStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *GetDatabaseResponse) Reset()                    { *m = GetDatabaseResponse{} }
func (m *GetDatabaseResponse) String() string            { return proto.CompactTextString(m) }
func (*GetDatabaseResponse) ProtoMessage()               {}
func (*GetDatabaseResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *GetDatabaseResponse) GetDatabase() *Database {
	if m != nil {
		return m.Database
	}
	return nil
}

func (m *GetDatabaseResponse) GetStatus() *RequestStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// Request to get list of databases
// If exclude_params is set, result may omit parameters
type ListDatabasesRequest struct {
	Catalog       string `protobuf:"bytes,1,opt,name=catalog" json:"catalog,omitempty"`
	Cookie        string `protobuf:"bytes,2,opt,name=cookie" json:"cookie,omitempty"`
	NamePattern   string `protobuf:"bytes,3,opt,name=name_pattern,json=namePattern" json:"name_pattern,omitempty"`
	ExcludeParams bool   `protobuf:"varint,4,opt,name=exclude_params,json=excludeParams" json:"exclude_params,omitempty"`
}

func (m *ListDatabasesRequest) Reset()                    { *m = ListDatabasesRequest{} }
func (m *ListDatabasesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListDatabasesRequest) ProtoMessage()               {}
func (*ListDatabasesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *ListDatabasesRequest) GetCatalog() string {
	if m != nil {
		return m.Catalog
	}
	return ""
}

func (m *ListDatabasesRequest) GetCookie() string {
	if m != nil {
		return m.Cookie
	}
	return ""
}

func (m *ListDatabasesRequest) GetNamePattern() string {
	if m != nil {
		return m.NamePattern
	}
	return ""
}

func (m *ListDatabasesRequest) GetExcludeParams() bool {
	if m != nil {
		return m.ExcludeParams
	}
	return false
}

// Request to drop a database.
// Dropping a database also drops all objects contained in the database.
// TODO: Add flag to prohibit dropping non-empty databases
type DropDatabaseRequest struct {
	Catalog string `protobuf:"bytes,1,opt,name=catalog" json:"catalog,omitempty"`
	Id      *Id    `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	Cookie  string `protobuf:"bytes,3,opt,name=cookie" json:"cookie,omitempty"`
}

func (m *DropDatabaseRequest) Reset()                    { *m = DropDatabaseRequest{} }
func (m *DropDatabaseRequest) String() string            { return proto.CompactTextString(m) }
func (*DropDatabaseRequest) ProtoMessage()               {}
func (*DropDatabaseRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *DropDatabaseRequest) GetCatalog() string {
	if m != nil {
		return m.Catalog
	}
	return ""
}

func (m *DropDatabaseRequest) GetId() *Id {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *DropDatabaseRequest) GetCookie() string {
	if m != nil {
		return m.Cookie
	}
	return ""
}

// FieldSchema defines name and type for each column.
type FieldSchema struct {
	Name    string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Type    string `protobuf:"bytes,2,opt,name=type" json:"type,omitempty"`
	Comment string `protobuf:"bytes,3,opt,name=comment" json:"comment,omitempty"`
}

func (m *FieldSchema) Reset()                    { *m = FieldSchema{} }
func (m *FieldSchema) String() string            { return proto.CompactTextString(m) }
func (*FieldSchema) ProtoMessage()               {}
func (*FieldSchema) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *FieldSchema) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FieldSchema) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *FieldSchema) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

// Serialization/Deserialization information
type SerDeInfo struct {
	Type             SerdeType `protobuf:"varint,1,opt,name=type,enum=metastore.SerdeType" json:"type,omitempty"`
	Name             string    `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	SerializationLib string    `protobuf:"bytes,3,opt,name=serializationLib" json:"serializationLib,omitempty"`
	// NOTE: Should we enum this as well?
	Parameters map[string]string `protobuf:"bytes,4,rep,name=parameters" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *SerDeInfo) Reset()                    { *m = SerDeInfo{} }
func (m *SerDeInfo) String() string            { return proto.CompactTextString(m) }
func (*SerDeInfo) ProtoMessage()               {}
func (*SerDeInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *SerDeInfo) GetType() SerdeType {
	if m != nil {
		return m.Type
	}
	return SerdeType_SERDE_CUSTOM
}

func (m *SerDeInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SerDeInfo) GetSerializationLib() string {
	if m != nil {
		return m.SerializationLib
	}
	return ""
}

func (m *SerDeInfo) GetParameters() map[string]string {
	if m != nil {
		return m.Parameters
	}
	return nil
}

// sort order of a column (column name along with asc/desc)
type Order struct {
	Col       string `protobuf:"bytes,1,opt,name=col" json:"col,omitempty"`
	Ascending bool   `protobuf:"varint,2,opt,name=ascending" json:"ascending,omitempty"`
}

func (m *Order) Reset()                    { *m = Order{} }
func (m *Order) String() string            { return proto.CompactTextString(m) }
func (*Order) ProtoMessage()               {}
func (*Order) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *Order) GetCol() string {
	if m != nil {
		return m.Col
	}
	return ""
}

func (m *Order) GetAscending() bool {
	if m != nil {
		return m.Ascending
	}
	return false
}

// StorageDescriptor holds all the information about physical storage of the data belonging to a table
type StorageDescriptor struct {
	Cols             []*FieldSchema    `protobuf:"bytes,1,rep,name=cols" json:"cols,omitempty"`
	Location         string            `protobuf:"bytes,2,opt,name=location" json:"location,omitempty"`
	InputFormat      InputFormat       `protobuf:"varint,3,opt,name=inputFormat,enum=metastore.InputFormat" json:"inputFormat,omitempty"`
	InputFormatName  string            `protobuf:"bytes,4,opt,name=inputFormatName" json:"inputFormatName,omitempty"`
	OutputFormat     OutputFormat      `protobuf:"varint,5,opt,name=outputFormat,enum=metastore.OutputFormat" json:"outputFormat,omitempty"`
	OutputFormatName string            `protobuf:"bytes,6,opt,name=outputFormatName" json:"outputFormatName,omitempty"`
	NumBuckets       int32             `protobuf:"varint,7,opt,name=numBuckets" json:"numBuckets,omitempty"`
	SerdeInfo        *SerDeInfo        `protobuf:"bytes,8,opt,name=serdeInfo" json:"serdeInfo,omitempty"`
	BucketCols       []string          `protobuf:"bytes,9,rep,name=bucketCols" json:"bucketCols,omitempty"`
	SortCols         []*Order          `protobuf:"bytes,10,rep,name=sortCols" json:"sortCols,omitempty"`
	Parameters       map[string]string `protobuf:"bytes,11,rep,name=parameters" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	SystemParameters map[string]string `protobuf:"bytes,12,rep,name=system_parameters,json=systemParameters" json:"system_parameters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *StorageDescriptor) Reset()                    { *m = StorageDescriptor{} }
func (m *StorageDescriptor) String() string            { return proto.CompactTextString(m) }
func (*StorageDescriptor) ProtoMessage()               {}
func (*StorageDescriptor) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *StorageDescriptor) GetCols() []*FieldSchema {
	if m != nil {
		return m.Cols
	}
	return nil
}

func (m *StorageDescriptor) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func (m *StorageDescriptor) GetInputFormat() InputFormat {
	if m != nil {
		return m.InputFormat
	}
	return InputFormat_IF_CUSTOM
}

func (m *StorageDescriptor) GetInputFormatName() string {
	if m != nil {
		return m.InputFormatName
	}
	return ""
}

func (m *StorageDescriptor) GetOutputFormat() OutputFormat {
	if m != nil {
		return m.OutputFormat
	}
	return OutputFormat_OF_CUSTOM
}

func (m *StorageDescriptor) GetOutputFormatName() string {
	if m != nil {
		return m.OutputFormatName
	}
	return ""
}

func (m *StorageDescriptor) GetNumBuckets() int32 {
	if m != nil {
		return m.NumBuckets
	}
	return 0
}

func (m *StorageDescriptor) GetSerdeInfo() *SerDeInfo {
	if m != nil {
		return m.SerdeInfo
	}
	return nil
}

func (m *StorageDescriptor) GetBucketCols() []string {
	if m != nil {
		return m.BucketCols
	}
	return nil
}

func (m *StorageDescriptor) GetSortCols() []*Order {
	if m != nil {
		return m.SortCols
	}
	return nil
}

func (m *StorageDescriptor) GetParameters() map[string]string {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *StorageDescriptor) GetSystemParameters() map[string]string {
	if m != nil {
		return m.SystemParameters
	}
	return nil
}

// Table information
type Table struct {
	Id               *Id                `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	SeqId            uint64             `protobuf:"varint,3,opt,name=seq_id,json=seqId" json:"seq_id,omitempty"`
	Sd               *StorageDescriptor `protobuf:"bytes,4,opt,name=sd" json:"sd,omitempty"`
	PartitionKeys    []*FieldSchema     `protobuf:"bytes,5,rep,name=partitionKeys" json:"partitionKeys,omitempty"`
	TableType        TableType          `protobuf:"varint,6,opt,name=tableType,enum=metastore.TableType" json:"tableType,omitempty"`
	Parameters       map[string]string  `protobuf:"bytes,7,rep,name=parameters" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	SystemParameters map[string]string  `protobuf:"bytes,8,rep,name=system_parameters,json=systemParameters" json:"system_parameters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Location         string             `protobuf:"bytes,9,opt,name=location" json:"location,omitempty"`
}

func (m *Table) Reset()                    { *m = Table{} }
func (m *Table) String() string            { return proto.CompactTextString(m) }
func (*Table) ProtoMessage()               {}
func (*Table) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *Table) GetId() *Id {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Table) GetSeqId() uint64 {
	if m != nil {
		return m.SeqId
	}
	return 0
}

func (m *Table) GetSd() *StorageDescriptor {
	if m != nil {
		return m.Sd
	}
	return nil
}

func (m *Table) GetPartitionKeys() []*FieldSchema {
	if m != nil {
		return m.PartitionKeys
	}
	return nil
}

func (m *Table) GetTableType() TableType {
	if m != nil {
		return m.TableType
	}
	return TableType_TTYPE_MANAGED
}

func (m *Table) GetParameters() map[string]string {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *Table) GetSystemParameters() map[string]string {
	if m != nil {
		return m.SystemParameters
	}
	return nil
}

func (m *Table) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

// Create a new table.
type CreateTableRequest struct {
	Catalog string `protobuf:"bytes,1,opt,name=catalog" json:"catalog,omitempty"`
	DbId    *Id    `protobuf:"bytes,2,opt,name=db_id,json=dbId" json:"db_id,omitempty"`
	Table   *Table `protobuf:"bytes,3,opt,name=table" json:"table,omitempty"`
	Cookie  string `protobuf:"bytes,4,opt,name=cookie" json:"cookie,omitempty"`
}

func (m *CreateTableRequest) Reset()                    { *m = CreateTableRequest{} }
func (m *CreateTableRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateTableRequest) ProtoMessage()               {}
func (*CreateTableRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *CreateTableRequest) GetCatalog() string {
	if m != nil {
		return m.Catalog
	}
	return ""
}

func (m *CreateTableRequest) GetDbId() *Id {
	if m != nil {
		return m.DbId
	}
	return nil
}

func (m *CreateTableRequest) GetTable() *Table {
	if m != nil {
		return m.Table
	}
	return nil
}

func (m *CreateTableRequest) GetCookie() string {
	if m != nil {
		return m.Cookie
	}
	return ""
}

// Request to get table by its ID.
type GetTableRequest struct {
	Catalog string `protobuf:"bytes,1,opt,name=catalog" json:"catalog,omitempty"`
	DbId    *Id    `protobuf:"bytes,2,opt,name=db_id,json=dbId" json:"db_id,omitempty"`
	Id      *Id    `protobuf:"bytes,3,opt,name=id" json:"id,omitempty"`
	Cookie  string `protobuf:"bytes,4,opt,name=cookie" json:"cookie,omitempty"`
}

func (m *GetTableRequest) Reset()                    { *m = GetTableRequest{} }
func (m *GetTableRequest) String() string            { return proto.CompactTextString(m) }
func (*GetTableRequest) ProtoMessage()               {}
func (*GetTableRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *GetTableRequest) GetCatalog() string {
	if m != nil {
		return m.Catalog
	}
	return ""
}

func (m *GetTableRequest) GetDbId() *Id {
	if m != nil {
		return m.DbId
	}
	return nil
}

func (m *GetTableRequest) GetId() *Id {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *GetTableRequest) GetCookie() string {
	if m != nil {
		return m.Cookie
	}
	return ""
}

type GetTableResponse struct {
	Table  *Table         `protobuf:"bytes,1,opt,name=table" json:"table,omitempty"`
	Status *RequestStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *GetTableResponse) Reset()                    { *m = GetTableResponse{} }
func (m *GetTableResponse) String() string            { return proto.CompactTextString(m) }
func (*GetTableResponse) ProtoMessage()               {}
func (*GetTableResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *GetTableResponse) GetTable() *Table {
	if m != nil {
		return m.Table
	}
	return nil
}

func (m *GetTableResponse) GetStatus() *RequestStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// Request to get list of databases.
type ListTablesRequest struct {
	Catalog string `protobuf:"bytes,1,opt,name=catalog" json:"catalog,omitempty"`
	DbId    *Id    `protobuf:"bytes,2,opt,name=db_id,json=dbId" json:"db_id,omitempty"`
	Cookie  string `protobuf:"bytes,3,opt,name=cookie" json:"cookie,omitempty"`
	// Field selectors.
	//
	// If specified, only certain fields are sent. The following fields are supported:
	//   - id: table Id
	//   - location: table location
	//   - parameters: table user parameters
	//   - partkeys: table partition keys
	Fields []string `protobuf:"bytes,4,rep,name=fields" json:"fields,omitempty"`
}

func (m *ListTablesRequest) Reset()                    { *m = ListTablesRequest{} }
func (m *ListTablesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListTablesRequest) ProtoMessage()               {}
func (*ListTablesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *ListTablesRequest) GetCatalog() string {
	if m != nil {
		return m.Catalog
	}
	return ""
}

func (m *ListTablesRequest) GetDbId() *Id {
	if m != nil {
		return m.DbId
	}
	return nil
}

func (m *ListTablesRequest) GetCookie() string {
	if m != nil {
		return m.Cookie
	}
	return ""
}

func (m *ListTablesRequest) GetFields() []string {
	if m != nil {
		return m.Fields
	}
	return nil
}

// Request to drop a table.
// Dropping a table also drops all objects contained in the table
// TODO: Add flag to prohibit dropping of non-empty table
type DropTableRequest struct {
	Catalog string `protobuf:"bytes,1,opt,name=catalog" json:"catalog,omitempty"`
	DbId    *Id    `protobuf:"bytes,2,opt,name=db_id,json=dbId" json:"db_id,omitempty"`
	Id      *Id    `protobuf:"bytes,3,opt,name=id" json:"id,omitempty"`
	Cookie  string `protobuf:"bytes,4,opt,name=cookie" json:"cookie,omitempty"`
}

func (m *DropTableRequest) Reset()                    { *m = DropTableRequest{} }
func (m *DropTableRequest) String() string            { return proto.CompactTextString(m) }
func (*DropTableRequest) ProtoMessage()               {}
func (*DropTableRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *DropTableRequest) GetCatalog() string {
	if m != nil {
		return m.Catalog
	}
	return ""
}

func (m *DropTableRequest) GetDbId() *Id {
	if m != nil {
		return m.DbId
	}
	return nil
}

func (m *DropTableRequest) GetId() *Id {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *DropTableRequest) GetCookie() string {
	if m != nil {
		return m.Cookie
	}
	return ""
}

// Partition
type Partition struct {
	SeqId      uint64             `protobuf:"varint,2,opt,name=seq_id,json=seqId" json:"seq_id,omitempty"`
	Values     []string           `protobuf:"bytes,3,rep,name=values" json:"values,omitempty"`
	Sd         *StorageDescriptor `protobuf:"bytes,4,opt,name=sd" json:"sd,omitempty"`
	Parameters map[string]string  `protobuf:"bytes,5,rep,name=parameters" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Location   string             `protobuf:"bytes,6,opt,name=location" json:"location,omitempty"`
}

func (m *Partition) Reset()                    { *m = Partition{} }
func (m *Partition) String() string            { return proto.CompactTextString(m) }
func (*Partition) ProtoMessage()               {}
func (*Partition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *Partition) GetSeqId() uint64 {
	if m != nil {
		return m.SeqId
	}
	return 0
}

func (m *Partition) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

func (m *Partition) GetSd() *StorageDescriptor {
	if m != nil {
		return m.Sd
	}
	return nil
}

func (m *Partition) GetParameters() map[string]string {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *Partition) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

// Add a single partition to a table.
//
// Partition is described by list of "values" - one value per partition schema.
// There is no validation that values actually match partition schema
type AddPartitionRequest struct {
	Catalog   string     `protobuf:"bytes,1,opt,name=catalog" json:"catalog,omitempty"`
	DbId      *Id        `protobuf:"bytes,2,opt,name=db_id,json=dbId" json:"db_id,omitempty"`
	TableId   *Id        `protobuf:"bytes,3,opt,name=table_id,json=tableId" json:"table_id,omitempty"`
	Partition *Partition `protobuf:"bytes,4,opt,name=partition" json:"partition,omitempty"`
}

func (m *AddPartitionRequest) Reset()                    { *m = AddPartitionRequest{} }
func (m *AddPartitionRequest) String() string            { return proto.CompactTextString(m) }
func (*AddPartitionRequest) ProtoMessage()               {}
func (*AddPartitionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *AddPartitionRequest) GetCatalog() string {
	if m != nil {
		return m.Catalog
	}
	return ""
}

func (m *AddPartitionRequest) GetDbId() *Id {
	if m != nil {
		return m.DbId
	}
	return nil
}

func (m *AddPartitionRequest) GetTableId() *Id {
	if m != nil {
		return m.TableId
	}
	return nil
}

func (m *AddPartitionRequest) GetPartition() *Partition {
	if m != nil {
		return m.Partition
	}
	return nil
}

// Get partition information.
//
// Partition is described by list of "values" - one value per partition schema.
// There is no validation that values actually match partition schema
type GetPartitionRequest struct {
	Catalog string   `protobuf:"bytes,1,opt,name=catalog" json:"catalog,omitempty"`
	DbId    *Id      `protobuf:"bytes,2,opt,name=db_id,json=dbId" json:"db_id,omitempty"`
	TableId *Id      `protobuf:"bytes,3,opt,name=table_id,json=tableId" json:"table_id,omitempty"`
	Values  []string `protobuf:"bytes,4,rep,name=values" json:"values,omitempty"`
}

func (m *GetPartitionRequest) Reset()                    { *m = GetPartitionRequest{} }
func (m *GetPartitionRequest) String() string            { return proto.CompactTextString(m) }
func (*GetPartitionRequest) ProtoMessage()               {}
func (*GetPartitionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *GetPartitionRequest) GetCatalog() string {
	if m != nil {
		return m.Catalog
	}
	return ""
}

func (m *GetPartitionRequest) GetDbId() *Id {
	if m != nil {
		return m.DbId
	}
	return nil
}

func (m *GetPartitionRequest) GetTableId() *Id {
	if m != nil {
		return m.TableId
	}
	return nil
}

func (m *GetPartitionRequest) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

type GetPartitionResponse struct {
	Partition *Partition     `protobuf:"bytes,1,opt,name=partition" json:"partition,omitempty"`
	Status    *RequestStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *GetPartitionResponse) Reset()                    { *m = GetPartitionResponse{} }
func (m *GetPartitionResponse) String() string            { return proto.CompactTextString(m) }
func (*GetPartitionResponse) ProtoMessage()               {}
func (*GetPartitionResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *GetPartitionResponse) GetPartition() *Partition {
	if m != nil {
		return m.Partition
	}
	return nil
}

func (m *GetPartitionResponse) GetStatus() *RequestStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// Return all partitions in a table
type ListPartitionsRequest struct {
	Catalog string `protobuf:"bytes,1,opt,name=catalog" json:"catalog,omitempty"`
	DbId    *Id    `protobuf:"bytes,2,opt,name=db_id,json=dbId" json:"db_id,omitempty"`
	TableId *Id    `protobuf:"bytes,3,opt,name=table_id,json=tableId" json:"table_id,omitempty"`
	Cookie  string `protobuf:"bytes,4,opt,name=cookie" json:"cookie,omitempty"`
	// Field selectors.
	//
	// If specified, only certain fields are sent. The following fields are supported:
	//   - location
	//   - values
	//   - parameters
	Fields []string `protobuf:"bytes,5,rep,name=fields" json:"fields,omitempty"`
}

func (m *ListPartitionsRequest) Reset()                    { *m = ListPartitionsRequest{} }
func (m *ListPartitionsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListPartitionsRequest) ProtoMessage()               {}
func (*ListPartitionsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *ListPartitionsRequest) GetCatalog() string {
	if m != nil {
		return m.Catalog
	}
	return ""
}

func (m *ListPartitionsRequest) GetDbId() *Id {
	if m != nil {
		return m.DbId
	}
	return nil
}

func (m *ListPartitionsRequest) GetTableId() *Id {
	if m != nil {
		return m.TableId
	}
	return nil
}

func (m *ListPartitionsRequest) GetCookie() string {
	if m != nil {
		return m.Cookie
	}
	return ""
}

func (m *ListPartitionsRequest) GetFields() []string {
	if m != nil {
		return m.Fields
	}
	return nil
}

// Delete partition.
//
// Partition is described by list of "values" - one value per partition schema.
// There is no validation that values actually match partition schema
type DropPartitionRequest struct {
	Catalog string   `protobuf:"bytes,1,opt,name=catalog" json:"catalog,omitempty"`
	DbId    *Id      `protobuf:"bytes,2,opt,name=db_id,json=dbId" json:"db_id,omitempty"`
	TableId *Id      `protobuf:"bytes,3,opt,name=table_id,json=tableId" json:"table_id,omitempty"`
	Values  []string `protobuf:"bytes,4,rep,name=values" json:"values,omitempty"`
	Cookie  string   `protobuf:"bytes,5,opt,name=cookie" json:"cookie,omitempty"`
}

func (m *DropPartitionRequest) Reset()                    { *m = DropPartitionRequest{} }
func (m *DropPartitionRequest) String() string            { return proto.CompactTextString(m) }
func (*DropPartitionRequest) ProtoMessage()               {}
func (*DropPartitionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *DropPartitionRequest) GetCatalog() string {
	if m != nil {
		return m.Catalog
	}
	return ""
}

func (m *DropPartitionRequest) GetDbId() *Id {
	if m != nil {
		return m.DbId
	}
	return nil
}

func (m *DropPartitionRequest) GetTableId() *Id {
	if m != nil {
		return m.TableId
	}
	return nil
}

func (m *DropPartitionRequest) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

func (m *DropPartitionRequest) GetCookie() string {
	if m != nil {
		return m.Cookie
	}
	return ""
}

func init() {
	proto.RegisterType((*RequestStatus)(nil), "metastore.RequestStatus")
	proto.RegisterType((*Id)(nil), "metastore.Id")
	proto.RegisterType((*Database)(nil), "metastore.Database")
	proto.RegisterType((*CreateDatabaseRequest)(nil), "metastore.CreateDatabaseRequest")
	proto.RegisterType((*AlterDatabaseRequest)(nil), "metastore.AlterDatabaseRequest")
	proto.RegisterType((*GetDatabaseRequest)(nil), "metastore.GetDatabaseRequest")
	proto.RegisterType((*GetDatabaseResponse)(nil), "metastore.GetDatabaseResponse")
	proto.RegisterType((*ListDatabasesRequest)(nil), "metastore.ListDatabasesRequest")
	proto.RegisterType((*DropDatabaseRequest)(nil), "metastore.DropDatabaseRequest")
	proto.RegisterType((*FieldSchema)(nil), "metastore.FieldSchema")
	proto.RegisterType((*SerDeInfo)(nil), "metastore.SerDeInfo")
	proto.RegisterType((*Order)(nil), "metastore.Order")
	proto.RegisterType((*StorageDescriptor)(nil), "metastore.StorageDescriptor")
	proto.RegisterType((*Table)(nil), "metastore.Table")
	proto.RegisterType((*CreateTableRequest)(nil), "metastore.CreateTableRequest")
	proto.RegisterType((*GetTableRequest)(nil), "metastore.GetTableRequest")
	proto.RegisterType((*GetTableResponse)(nil), "metastore.GetTableResponse")
	proto.RegisterType((*ListTablesRequest)(nil), "metastore.ListTablesRequest")
	proto.RegisterType((*DropTableRequest)(nil), "metastore.DropTableRequest")
	proto.RegisterType((*Partition)(nil), "metastore.Partition")
	proto.RegisterType((*AddPartitionRequest)(nil), "metastore.AddPartitionRequest")
	proto.RegisterType((*GetPartitionRequest)(nil), "metastore.GetPartitionRequest")
	proto.RegisterType((*GetPartitionResponse)(nil), "metastore.GetPartitionResponse")
	proto.RegisterType((*ListPartitionsRequest)(nil), "metastore.ListPartitionsRequest")
	proto.RegisterType((*DropPartitionRequest)(nil), "metastore.DropPartitionRequest")
	proto.RegisterEnum("metastore.SerdeType", SerdeType_name, SerdeType_value)
	proto.RegisterEnum("metastore.InputFormat", InputFormat_name, InputFormat_value)
	proto.RegisterEnum("metastore.OutputFormat", OutputFormat_name, OutputFormat_value)
	proto.RegisterEnum("metastore.TableType", TableType_name, TableType_value)
	proto.RegisterEnum("metastore.SerializationLib", SerializationLib_name, SerializationLib_value)
	proto.RegisterEnum("metastore.RequestStatus_Status", RequestStatus_Status_name, RequestStatus_Status_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Metastore service

type MetastoreClient interface {
	// Create a new database.
	CreateDabatase(ctx context.Context, in *CreateDatabaseRequest, opts ...grpc.CallOption) (*GetDatabaseResponse, error)
	// Get database information
	GetDatabase(ctx context.Context, in *GetDatabaseRequest, opts ...grpc.CallOption) (*GetDatabaseResponse, error)
	// Return all databases in a catalog
	ListDatabases(ctx context.Context, in *ListDatabasesRequest, opts ...grpc.CallOption) (Metastore_ListDatabasesClient, error)
	// Destroy the database
	DropDatabase(ctx context.Context, in *DropDatabaseRequest, opts ...grpc.CallOption) (*RequestStatus, error)
	// Alter database
	AlterDatabase(ctx context.Context, in *AlterDatabaseRequest, opts ...grpc.CallOption) (*GetDatabaseResponse, error)
	// Create a new table
	CreateTable(ctx context.Context, in *CreateTableRequest, opts ...grpc.CallOption) (*GetTableResponse, error)
	// Get table information
	GetTable(ctx context.Context, in *GetTableRequest, opts ...grpc.CallOption) (*GetTableResponse, error)
	// Get all tables from a database
	ListTables(ctx context.Context, in *ListTablesRequest, opts ...grpc.CallOption) (Metastore_ListTablesClient, error)
	// Destroy a table
	DropTable(ctx context.Context, in *DropTableRequest, opts ...grpc.CallOption) (*RequestStatus, error)
	// Add partition to a table
	AddPartition(ctx context.Context, in *AddPartitionRequest, opts ...grpc.CallOption) (*RequestStatus, error)
	// Get partition information
	GetPartition(ctx context.Context, in *GetPartitionRequest, opts ...grpc.CallOption) (*GetPartitionResponse, error)
	// List all partitions in a table
	ListPartitions(ctx context.Context, in *ListPartitionsRequest, opts ...grpc.CallOption) (Metastore_ListPartitionsClient, error)
	// Drop partition
	DropPartition(ctx context.Context, in *DropPartitionRequest, opts ...grpc.CallOption) (*RequestStatus, error)
}

type metastoreClient struct {
	cc *grpc.ClientConn
}

func NewMetastoreClient(cc *grpc.ClientConn) MetastoreClient {
	return &metastoreClient{cc}
}

func (c *metastoreClient) CreateDabatase(ctx context.Context, in *CreateDatabaseRequest, opts ...grpc.CallOption) (*GetDatabaseResponse, error) {
	out := new(GetDatabaseResponse)
	err := grpc.Invoke(ctx, "/metastore.Metastore/CreateDabatase", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metastoreClient) GetDatabase(ctx context.Context, in *GetDatabaseRequest, opts ...grpc.CallOption) (*GetDatabaseResponse, error) {
	out := new(GetDatabaseResponse)
	err := grpc.Invoke(ctx, "/metastore.Metastore/GetDatabase", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metastoreClient) ListDatabases(ctx context.Context, in *ListDatabasesRequest, opts ...grpc.CallOption) (Metastore_ListDatabasesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Metastore_serviceDesc.Streams[0], c.cc, "/metastore.Metastore/ListDatabases", opts...)
	if err != nil {
		return nil, err
	}
	x := &metastoreListDatabasesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Metastore_ListDatabasesClient interface {
	Recv() (*Database, error)
	grpc.ClientStream
}

type metastoreListDatabasesClient struct {
	grpc.ClientStream
}

func (x *metastoreListDatabasesClient) Recv() (*Database, error) {
	m := new(Database)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *metastoreClient) DropDatabase(ctx context.Context, in *DropDatabaseRequest, opts ...grpc.CallOption) (*RequestStatus, error) {
	out := new(RequestStatus)
	err := grpc.Invoke(ctx, "/metastore.Metastore/DropDatabase", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metastoreClient) AlterDatabase(ctx context.Context, in *AlterDatabaseRequest, opts ...grpc.CallOption) (*GetDatabaseResponse, error) {
	out := new(GetDatabaseResponse)
	err := grpc.Invoke(ctx, "/metastore.Metastore/AlterDatabase", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metastoreClient) CreateTable(ctx context.Context, in *CreateTableRequest, opts ...grpc.CallOption) (*GetTableResponse, error) {
	out := new(GetTableResponse)
	err := grpc.Invoke(ctx, "/metastore.Metastore/CreateTable", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metastoreClient) GetTable(ctx context.Context, in *GetTableRequest, opts ...grpc.CallOption) (*GetTableResponse, error) {
	out := new(GetTableResponse)
	err := grpc.Invoke(ctx, "/metastore.Metastore/GetTable", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metastoreClient) ListTables(ctx context.Context, in *ListTablesRequest, opts ...grpc.CallOption) (Metastore_ListTablesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Metastore_serviceDesc.Streams[1], c.cc, "/metastore.Metastore/ListTables", opts...)
	if err != nil {
		return nil, err
	}
	x := &metastoreListTablesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Metastore_ListTablesClient interface {
	Recv() (*Table, error)
	grpc.ClientStream
}

type metastoreListTablesClient struct {
	grpc.ClientStream
}

func (x *metastoreListTablesClient) Recv() (*Table, error) {
	m := new(Table)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *metastoreClient) DropTable(ctx context.Context, in *DropTableRequest, opts ...grpc.CallOption) (*RequestStatus, error) {
	out := new(RequestStatus)
	err := grpc.Invoke(ctx, "/metastore.Metastore/DropTable", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metastoreClient) AddPartition(ctx context.Context, in *AddPartitionRequest, opts ...grpc.CallOption) (*RequestStatus, error) {
	out := new(RequestStatus)
	err := grpc.Invoke(ctx, "/metastore.Metastore/AddPartition", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metastoreClient) GetPartition(ctx context.Context, in *GetPartitionRequest, opts ...grpc.CallOption) (*GetPartitionResponse, error) {
	out := new(GetPartitionResponse)
	err := grpc.Invoke(ctx, "/metastore.Metastore/GetPartition", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metastoreClient) ListPartitions(ctx context.Context, in *ListPartitionsRequest, opts ...grpc.CallOption) (Metastore_ListPartitionsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Metastore_serviceDesc.Streams[2], c.cc, "/metastore.Metastore/ListPartitions", opts...)
	if err != nil {
		return nil, err
	}
	x := &metastoreListPartitionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Metastore_ListPartitionsClient interface {
	Recv() (*Partition, error)
	grpc.ClientStream
}

type metastoreListPartitionsClient struct {
	grpc.ClientStream
}

func (x *metastoreListPartitionsClient) Recv() (*Partition, error) {
	m := new(Partition)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *metastoreClient) DropPartition(ctx context.Context, in *DropPartitionRequest, opts ...grpc.CallOption) (*RequestStatus, error) {
	out := new(RequestStatus)
	err := grpc.Invoke(ctx, "/metastore.Metastore/DropPartition", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Metastore service

type MetastoreServer interface {
	// Create a new database.
	CreateDabatase(context.Context, *CreateDatabaseRequest) (*GetDatabaseResponse, error)
	// Get database information
	GetDatabase(context.Context, *GetDatabaseRequest) (*GetDatabaseResponse, error)
	// Return all databases in a catalog
	ListDatabases(*ListDatabasesRequest, Metastore_ListDatabasesServer) error
	// Destroy the database
	DropDatabase(context.Context, *DropDatabaseRequest) (*RequestStatus, error)
	// Alter database
	AlterDatabase(context.Context, *AlterDatabaseRequest) (*GetDatabaseResponse, error)
	// Create a new table
	CreateTable(context.Context, *CreateTableRequest) (*GetTableResponse, error)
	// Get table information
	GetTable(context.Context, *GetTableRequest) (*GetTableResponse, error)
	// Get all tables from a database
	ListTables(*ListTablesRequest, Metastore_ListTablesServer) error
	// Destroy a table
	DropTable(context.Context, *DropTableRequest) (*RequestStatus, error)
	// Add partition to a table
	AddPartition(context.Context, *AddPartitionRequest) (*RequestStatus, error)
	// Get partition information
	GetPartition(context.Context, *GetPartitionRequest) (*GetPartitionResponse, error)
	// List all partitions in a table
	ListPartitions(*ListPartitionsRequest, Metastore_ListPartitionsServer) error
	// Drop partition
	DropPartition(context.Context, *DropPartitionRequest) (*RequestStatus, error)
}

func RegisterMetastoreServer(s *grpc.Server, srv MetastoreServer) {
	s.RegisterService(&_Metastore_serviceDesc, srv)
}

func _Metastore_CreateDabatase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDatabaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetastoreServer).CreateDabatase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/metastore.Metastore/CreateDabatase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetastoreServer).CreateDabatase(ctx, req.(*CreateDatabaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Metastore_GetDatabase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDatabaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetastoreServer).GetDatabase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/metastore.Metastore/GetDatabase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetastoreServer).GetDatabase(ctx, req.(*GetDatabaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Metastore_ListDatabases_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListDatabasesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MetastoreServer).ListDatabases(m, &metastoreListDatabasesServer{stream})
}

type Metastore_ListDatabasesServer interface {
	Send(*Database) error
	grpc.ServerStream
}

type metastoreListDatabasesServer struct {
	grpc.ServerStream
}

func (x *metastoreListDatabasesServer) Send(m *Database) error {
	return x.ServerStream.SendMsg(m)
}

func _Metastore_DropDatabase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DropDatabaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetastoreServer).DropDatabase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/metastore.Metastore/DropDatabase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetastoreServer).DropDatabase(ctx, req.(*DropDatabaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Metastore_AlterDatabase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AlterDatabaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetastoreServer).AlterDatabase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/metastore.Metastore/AlterDatabase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetastoreServer).AlterDatabase(ctx, req.(*AlterDatabaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Metastore_CreateTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetastoreServer).CreateTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/metastore.Metastore/CreateTable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetastoreServer).CreateTable(ctx, req.(*CreateTableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Metastore_GetTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetastoreServer).GetTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/metastore.Metastore/GetTable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetastoreServer).GetTable(ctx, req.(*GetTableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Metastore_ListTables_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListTablesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MetastoreServer).ListTables(m, &metastoreListTablesServer{stream})
}

type Metastore_ListTablesServer interface {
	Send(*Table) error
	grpc.ServerStream
}

type metastoreListTablesServer struct {
	grpc.ServerStream
}

func (x *metastoreListTablesServer) Send(m *Table) error {
	return x.ServerStream.SendMsg(m)
}

func _Metastore_DropTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DropTableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetastoreServer).DropTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/metastore.Metastore/DropTable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetastoreServer).DropTable(ctx, req.(*DropTableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Metastore_AddPartition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddPartitionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetastoreServer).AddPartition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/metastore.Metastore/AddPartition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetastoreServer).AddPartition(ctx, req.(*AddPartitionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Metastore_GetPartition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPartitionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetastoreServer).GetPartition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/metastore.Metastore/GetPartition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetastoreServer).GetPartition(ctx, req.(*GetPartitionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Metastore_ListPartitions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListPartitionsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MetastoreServer).ListPartitions(m, &metastoreListPartitionsServer{stream})
}

type Metastore_ListPartitionsServer interface {
	Send(*Partition) error
	grpc.ServerStream
}

type metastoreListPartitionsServer struct {
	grpc.ServerStream
}

func (x *metastoreListPartitionsServer) Send(m *Partition) error {
	return x.ServerStream.SendMsg(m)
}

func _Metastore_DropPartition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DropPartitionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetastoreServer).DropPartition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/metastore.Metastore/DropPartition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetastoreServer).DropPartition(ctx, req.(*DropPartitionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Metastore_serviceDesc = grpc.ServiceDesc{
	ServiceName: "metastore.Metastore",
	HandlerType: (*MetastoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateDabatase",
			Handler:    _Metastore_CreateDabatase_Handler,
		},
		{
			MethodName: "GetDatabase",
			Handler:    _Metastore_GetDatabase_Handler,
		},
		{
			MethodName: "DropDatabase",
			Handler:    _Metastore_DropDatabase_Handler,
		},
		{
			MethodName: "AlterDatabase",
			Handler:    _Metastore_AlterDatabase_Handler,
		},
		{
			MethodName: "CreateTable",
			Handler:    _Metastore_CreateTable_Handler,
		},
		{
			MethodName: "GetTable",
			Handler:    _Metastore_GetTable_Handler,
		},
		{
			MethodName: "DropTable",
			Handler:    _Metastore_DropTable_Handler,
		},
		{
			MethodName: "AddPartition",
			Handler:    _Metastore_AddPartition_Handler,
		},
		{
			MethodName: "GetPartition",
			Handler:    _Metastore_GetPartition_Handler,
		},
		{
			MethodName: "DropPartition",
			Handler:    _Metastore_DropPartition_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListDatabases",
			Handler:       _Metastore_ListDatabases_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListTables",
			Handler:       _Metastore_ListTables_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListPartitions",
			Handler:       _Metastore_ListPartitions_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "metastore.proto",
}

func init() { proto.RegisterFile("metastore.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1978 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x59, 0x4f, 0x6f, 0xe3, 0xc6,
	0x15, 0x5f, 0x52, 0x92, 0x2d, 0x3d, 0x59, 0x32, 0x3d, 0xb6, 0x37, 0x82, 0xe2, 0xdd, 0xa8, 0x6c,
	0x1b, 0xa8, 0x86, 0x63, 0x39, 0x6a, 0xd3, 0x0d, 0xd2, 0x04, 0x88, 0x2c, 0x51, 0x36, 0xb3, 0x5a,
	0x51, 0xa1, 0x64, 0x63, 0xb7, 0x17, 0x81, 0x12, 0x67, 0x65, 0x66, 0x25, 0x51, 0x4b, 0x52, 0x9b,
	0x38, 0xe9, 0x1e, 0xda, 0x43, 0x8b, 0x1c, 0x7a, 0xd9, 0xb6, 0x40, 0x3f, 0x42, 0x4f, 0x2d, 0xda,
	0xaf, 0xd2, 0x4b, 0x2f, 0xbd, 0xf5, 0x23, 0xf4, 0x54, 0x20, 0x40, 0x31, 0x43, 0x4a, 0x9c, 0x91,
	0x29, 0xff, 0x69, 0x5d, 0x6c, 0x7a, 0x12, 0xe7, 0xcd, 0xe3, 0xef, 0xfd, 0x9d, 0xf7, 0x1e, 0x47,
	0xb0, 0x3e, 0xc2, 0x9e, 0xe1, 0x7a, 0xb6, 0x83, 0xf7, 0x27, 0x8e, 0xed, 0xd9, 0x28, 0x35, 0x27,
	0xe4, 0x77, 0x06, 0xb6, 0x3d, 0x18, 0xe2, 0x92, 0x31, 0xb1, 0x4a, 0xc6, 0x78, 0x6c, 0x7b, 0x86,
	0x67, 0xd9, 0x63, 0xd7, 0x67, 0xcc, 0xef, 0xd1, 0x9f, 0xfe, 0x3b, 0x03, 0x3c, 0x7e, 0xc7, 0xfd,
	0xdc, 0x18, 0x0c, 0xb0, 0x53, 0xb2, 0x27, 0x94, 0xe3, 0x22, 0xb7, 0xfc, 0x77, 0x01, 0x32, 0x3a,
	0x7e, 0x3e, 0xc5, 0xae, 0xd7, 0xf6, 0x0c, 0x6f, 0xea, 0xa2, 0x07, 0xb0, 0xe2, 0xd2, 0xa7, 0x9c,
	0x50, 0x10, 0x8a, 0xd9, 0xf2, 0x5b, 0xfb, 0xa1, 0x2a, 0x1c, 0xe7, 0xbe, 0xff, 0xa3, 0x07, 0xec,
	0x68, 0x0b, 0x12, 0xd8, 0x71, 0x6c, 0x27, 0x27, 0x16, 0x84, 0x62, 0x4a, 0xf7, 0x17, 0xf2, 0x4b,
	0x58, 0x09, 0x80, 0x33, 0x90, 0x6a, 0x77, 0x2a, 0x9d, 0x93, 0x76, 0x57, 0x7b, 0x28, 0xdd, 0x41,
	0x12, 0xac, 0x05, 0x4b, 0x45, 0xd7, 0x35, 0x5d, 0x12, 0xd0, 0x26, 0xac, 0x07, 0x94, 0xa6, 0xd6,
	0xa9, 0x6b, 0x27, 0xcd, 0x9a, 0x24, 0x32, 0xc4, 0xaa, 0xd6, 0xac, 0x37, 0xd4, 0x6a, 0x47, 0x8a,
	0xa1, 0x75, 0x48, 0x07, 0xc4, 0xc3, 0x93, 0xf6, 0x13, 0x29, 0x8e, 0xde, 0x80, 0xcd, 0x80, 0xa0,
	0x36, 0x3b, 0x8a, 0xde, 0xac, 0x34, 0x08, 0xaa, 0x94, 0x90, 0x8b, 0x20, 0xaa, 0x26, 0x42, 0x10,
	0x1f, 0x1b, 0x23, 0x4c, 0x2d, 0x4a, 0xe9, 0xf4, 0x19, 0x65, 0x41, 0xb4, 0xcc, 0x40, 0x57, 0xd1,
	0x32, 0xe5, 0x6f, 0x44, 0x48, 0xd6, 0x0c, 0xcf, 0xe8, 0x19, 0x2e, 0x46, 0xf7, 0xe8, 0x26, 0x61,
	0x4f, 0x97, 0x33, 0x8c, 0x03, 0x54, 0x93, 0xf0, 0xa2, 0x6d, 0x58, 0x71, 0xf1, 0xf3, 0x6e, 0xf0,
	0x7e, 0x5c, 0x4f, 0xb8, 0xf8, 0xb9, 0x6a, 0xa2, 0x3c, 0x24, 0x87, 0x76, 0x9f, 0xfa, 0x37, 0x17,
	0xa3, 0xc0, 0xf3, 0x35, 0xaa, 0x02, 0x4c, 0x0c, 0xc7, 0x18, 0x61, 0x0f, 0x3b, 0x6e, 0x2e, 0x5e,
	0x88, 0x15, 0xd3, 0xe5, 0xef, 0x32, 0xc8, 0x33, 0xd1, 0xfb, 0xad, 0x39, 0x97, 0x32, 0xf6, 0x9c,
	0x73, 0x9d, 0x79, 0x0d, 0x9d, 0xc2, 0x86, 0x7b, 0xee, 0x7a, 0x78, 0xd4, 0x65, 0xb0, 0x12, 0x14,
	0xeb, 0x07, 0x51, 0x58, 0x6d, 0xca, 0xbc, 0x88, 0x28, 0xb9, 0x0b, 0xe4, 0xfc, 0x47, 0xb0, 0xbe,
	0xc0, 0x84, 0x24, 0x88, 0x3d, 0xc3, 0xe7, 0x81, 0xc7, 0xc8, 0x23, 0x89, 0xef, 0x0b, 0x63, 0x38,
	0xc5, 0xb3, 0xf8, 0xd2, 0xc5, 0x07, 0xe2, 0xfb, 0x42, 0xbe, 0x0a, 0xdb, 0x91, 0x92, 0x6e, 0x02,
	0x22, 0x7f, 0x09, 0xdb, 0x55, 0x07, 0x1b, 0x1e, 0x9e, 0x69, 0x1f, 0x24, 0x1b, 0xca, 0xc1, 0x6a,
	0xdf, 0xf0, 0x8c, 0xa1, 0x3d, 0x08, 0x80, 0x66, 0x4b, 0x54, 0x82, 0xa4, 0x19, 0x30, 0x53, 0xbc,
	0x74, 0x79, 0x33, 0xc2, 0x0b, 0xfa, 0x9c, 0x09, 0xdd, 0x85, 0x95, 0xbe, 0x6d, 0x3f, 0xb3, 0x70,
	0x10, 0x9e, 0x60, 0x25, 0xff, 0x5e, 0x80, 0xad, 0xca, 0xd0, 0xc3, 0xce, 0xf5, 0x65, 0xdf, 0x9b,
	0xa7, 0x4f, 0x64, 0x86, 0xb0, 0xaa, 0xc5, 0x6e, 0xa6, 0x5a, 0x9c, 0x53, 0x0d, 0x03, 0x3a, 0xc2,
	0xde, 0xad, 0xe9, 0xb5, 0xcc, 0x03, 0x5f, 0xc0, 0x26, 0x27, 0xc6, 0x9d, 0xd8, 0x63, 0x17, 0x73,
	0x66, 0x08, 0xd7, 0x31, 0xe3, 0x60, 0x5e, 0x3d, 0x7c, 0x15, 0x72, 0xcb, 0xaa, 0xc7, 0xac, 0x6c,
	0xc8, 0xaf, 0x04, 0xd8, 0x6a, 0x58, 0xee, 0x5c, 0xb6, 0x7b, 0xb5, 0x8d, 0xa1, 0x11, 0x22, 0x6b,
	0x04, 0xfa, 0x0e, 0xac, 0x91, 0xa3, 0xdd, 0x9d, 0x18, 0x9e, 0x87, 0x9d, 0xd9, 0x19, 0x4c, 0x13,
	0x5a, 0xcb, 0x27, 0xa1, 0xef, 0x43, 0x16, 0x7f, 0xd1, 0x1f, 0x4e, 0x4d, 0xec, 0x1f, 0x21, 0x97,
	0xba, 0x3b, 0xa9, 0x67, 0x02, 0x2a, 0xcd, 0x60, 0x57, 0x7e, 0x0a, 0x9b, 0x35, 0xc7, 0x9e, 0xfc,
	0xcf, 0xdd, 0xae, 0x41, 0xba, 0x6e, 0xe1, 0xa1, 0xd9, 0xee, 0x9f, 0xe1, 0x91, 0x11, 0x59, 0xa7,
	0x10, 0xc4, 0xbd, 0xf3, 0xc9, 0xcc, 0x54, 0xfa, 0x4c, 0xf5, 0xb0, 0x47, 0x23, 0x3c, 0xf6, 0x02,
	0xbc, 0xd9, 0x52, 0xfe, 0x97, 0x00, 0xa9, 0x36, 0x76, 0x6a, 0x58, 0x1d, 0x3f, 0xb5, 0x51, 0x31,
	0x78, 0xd7, 0xaf, 0xe4, 0x5b, 0x8c, 0x5e, 0x6d, 0xec, 0x98, 0xb8, 0x73, 0x3e, 0xc1, 0x01, 0xe2,
	0x4c, 0xb2, 0xc8, 0x48, 0xde, 0x05, 0xc9, 0xc5, 0x8e, 0x65, 0x0c, 0xad, 0x2f, 0x69, 0x0d, 0x6b,
	0x58, 0xbd, 0x40, 0xdc, 0x05, 0x3a, 0xaa, 0x45, 0x94, 0xb7, 0xef, 0xf1, 0xf2, 0x7c, 0x9d, 0x2e,
	0xab, 0x6f, 0xff, 0x65, 0x1d, 0x92, 0x1f, 0x40, 0x42, 0x73, 0x4c, 0xec, 0x90, 0x97, 0xfa, 0xf6,
	0x70, 0xf6, 0x52, 0xdf, 0x1e, 0xa2, 0x1d, 0x48, 0x19, 0x6e, 0x1f, 0x8f, 0x4d, 0x6b, 0x3c, 0xa0,
	0x2f, 0x26, 0xf5, 0x90, 0x20, 0x7f, 0x93, 0x80, 0x8d, 0xb6, 0x67, 0x3b, 0xc6, 0x00, 0xd7, 0xb0,
	0xdb, 0x77, 0xac, 0x89, 0x67, 0x3b, 0x68, 0x17, 0xe2, 0x7d, 0x7b, 0x48, 0xfa, 0x20, 0xb1, 0xe6,
	0x2e, 0x63, 0x0d, 0x13, 0x33, 0x9d, 0xf2, 0x70, 0xa5, 0x5f, 0x5c, 0x28, 0xfd, 0xef, 0x43, 0xda,
	0x1a, 0x4f, 0xa6, 0x5e, 0xdd, 0x76, 0x46, 0x86, 0x1f, 0xb1, 0x2c, 0x07, 0xa7, 0x86, 0xbb, 0x3a,
	0xcb, 0x8a, 0x8a, 0xb0, 0xce, 0x2c, 0x9b, 0x24, 0x40, 0x7e, 0x75, 0x58, 0x24, 0xa3, 0x9f, 0xc0,
	0x9a, 0x3d, 0xf5, 0x42, 0x21, 0x09, 0x2a, 0xe4, 0x0d, 0x46, 0x88, 0xc6, 0x6c, 0xeb, 0x1c, 0x33,
	0x09, 0x34, 0xbb, 0xa6, 0x72, 0x56, 0xfc, 0x40, 0x2f, 0xd2, 0xd1, 0x7d, 0x80, 0xf1, 0x74, 0x74,
	0x38, 0xed, 0x3f, 0xc3, 0x9e, 0x9b, 0x5b, 0x2d, 0x08, 0xc5, 0x84, 0xce, 0x50, 0x50, 0x19, 0x52,
	0x2e, 0xc9, 0x2d, 0x12, 0xeb, 0x5c, 0x92, 0x9e, 0x87, 0xad, 0xa8, 0x3c, 0xd0, 0x43, 0x36, 0x82,
	0xd9, 0xa3, 0xaf, 0x57, 0x89, 0xbb, 0x53, 0x85, 0x58, 0x31, 0xa5, 0x33, 0x14, 0xb4, 0x07, 0x49,
	0xd7, 0x76, 0xfc, 0x5d, 0xa0, 0xc1, 0x90, 0x58, 0xc3, 0x48, 0xc8, 0xf5, 0x39, 0x07, 0x6a, 0x70,
	0xa9, 0x98, 0xa6, 0xfc, 0x7b, 0xac, 0x0a, 0x8b, 0x81, 0xbe, 0xb4, 0xe5, 0x76, 0xa3, 0x5a, 0xee,
	0x1a, 0x05, 0x2d, 0x5f, 0x0a, 0xfa, 0xff, 0xd4, 0x7b, 0x7f, 0x1b, 0x87, 0x44, 0xc7, 0xe8, 0x0d,
	0x6f, 0x30, 0xf8, 0xc4, 0xd8, 0xc1, 0x67, 0x0f, 0x44, 0xd7, 0xa4, 0xa9, 0x99, 0x2e, 0xef, 0x5c,
	0xe6, 0x15, 0x5d, 0x74, 0x4d, 0xf4, 0x21, 0x64, 0x26, 0x86, 0xe3, 0x59, 0xe4, 0x70, 0x3c, 0xc4,
	0xe7, 0xb3, 0x09, 0x66, 0xd9, 0x01, 0xe3, 0x99, 0x49, 0x82, 0x79, 0x44, 0x55, 0x52, 0xbc, 0x68,
	0x96, 0xf2, 0x85, 0xad, 0x33, 0xdb, 0xd3, 0x43, 0x36, 0xf4, 0x31, 0x97, 0x12, 0xab, 0x54, 0x5c,
	0x61, 0xf1, 0xa5, 0x4b, 0xd3, 0xa0, 0x1d, 0x95, 0x06, 0x49, 0x0a, 0xf4, 0xf6, 0x05, 0xa0, 0x6b,
	0x86, 0x9e, 0x2b, 0x1a, 0x29, 0xbe, 0x68, 0x7c, 0x2b, 0xd2, 0xe2, 0x95, 0x00, 0xc8, 0x9f, 0xc9,
	0xa8, 0x5d, 0x57, 0x77, 0x41, 0x19, 0x12, 0x66, 0xaf, 0xbb, 0xac, 0x11, 0xc6, 0xcd, 0x9e, 0x6a,
	0xa2, 0xb7, 0x21, 0x41, 0x03, 0x13, 0x8c, 0x45, 0xd2, 0xa2, 0xf7, 0x74, 0x7f, 0x7b, 0xe9, 0x40,
	0xf4, 0x4b, 0x01, 0xd6, 0x8f, 0xb0, 0x77, 0x8b, 0x1a, 0xf9, 0x39, 0x1f, 0xbb, 0xba, 0x77, 0xf3,
	0x8a, 0x0c, 0x41, 0x0a, 0xf5, 0x08, 0xe6, 0xa5, 0xb9, 0x71, 0xc2, 0xe5, 0xc6, 0xdd, 0x7c, 0x4c,
	0xfa, 0xb9, 0x00, 0x1b, 0x64, 0x4c, 0xa2, 0x30, 0xee, 0xed, 0x18, 0xbe, 0x64, 0x2a, 0x21, 0xf4,
	0xa7, 0xe4, 0x00, 0xfa, 0x8d, 0x3c, 0xa5, 0x07, 0x2b, 0xf9, 0x57, 0x02, 0x48, 0x64, 0x2c, 0x7a,
	0xfd, 0xbe, 0xff, 0x5a, 0x84, 0x54, 0x6b, 0x56, 0x16, 0x96, 0x7d, 0x8e, 0xdd, 0x85, 0x15, 0x9a,
	0xcb, 0x6e, 0x2e, 0xe6, 0x9b, 0xe1, 0xaf, 0x6e, 0x58, 0xad, 0xf8, 0xc9, 0x26, 0x71, 0x61, 0xb2,
	0x99, 0xab, 0x71, 0x69, 0xfd, 0x60, 0x8f, 0xfa, 0xca, 0xad, 0x1e, 0x75, 0xf9, 0xcf, 0x02, 0x6c,
	0x56, 0x4c, 0x73, 0xae, 0xc7, 0xed, 0x04, 0xa6, 0x08, 0x49, 0x9a, 0xaa, 0xdd, 0x65, 0xe1, 0x59,
	0xa5, 0xdb, 0xaa, 0x49, 0x0a, 0xf2, 0xbc, 0x42, 0x07, 0x5e, 0xdd, 0x8a, 0xf2, 0x8f, 0x1e, 0xb2,
	0xc9, 0xbf, 0x13, 0xe8, 0xf7, 0xc6, 0x6b, 0xd3, 0x39, 0x4c, 0x8d, 0x38, 0x9b, 0x1a, 0xf2, 0xcf,
	0x60, 0x8b, 0x57, 0x2b, 0x38, 0xd7, 0x9c, 0x8d, 0xc2, 0xb5, 0x6c, 0xfc, 0x0f, 0xce, 0xf8, 0x9f,
	0x04, 0xd8, 0x26, 0x67, 0x7c, 0x0e, 0xe7, 0xbe, 0x06, 0xbf, 0x44, 0x9d, 0x37, 0xa6, 0x22, 0x24,
	0xb8, 0x8a, 0xf0, 0x47, 0x01, 0xb6, 0x48, 0x45, 0xf8, 0xb6, 0x05, 0x92, 0x31, 0x24, 0xc1, 0x1a,
	0xb2, 0xfb, 0x07, 0xff, 0xfb, 0xc8, 0xff, 0xf6, 0xa1, 0x77, 0x50, 0x8a, 0x5e, 0x53, 0xba, 0xd5,
	0x93, 0x76, 0x47, 0x7b, 0x24, 0xdd, 0x41, 0xdb, 0xb0, 0xe1, 0x53, 0x1a, 0x95, 0x9f, 0x3e, 0xe9,
	0xb6, 0xd5, 0x47, 0xad, 0x86, 0x22, 0x09, 0x28, 0x0b, 0xe0, 0x93, 0x2b, 0xa7, 0xba, 0x26, 0x89,
	0xe1, 0xfa, 0x93, 0xb6, 0xd6, 0x94, 0x62, 0xf4, 0x6e, 0x8b, 0xae, 0x35, 0xbd, 0x2a, 0xc5, 0xe9,
	0xfd, 0x14, 0x5d, 0xea, 0xca, 0x91, 0xf2, 0x58, 0x4a, 0x84, 0x82, 0x3a, 0xc7, 0xba, 0x5a, 0xef,
	0x48, 0x2b, 0x68, 0x03, 0x32, 0x3e, 0xa5, 0x55, 0xd1, 0x3f, 0x3d, 0x51, 0x3a, 0xd2, 0x6a, 0x08,
	0x52, 0x6d, 0x9f, 0x4a, 0xc9, 0xdd, 0x23, 0x48, 0x33, 0x1f, 0x06, 0x64, 0x57, 0xad, 0x87, 0x8a,
	0xae, 0x43, 0x5a, 0xad, 0x77, 0xdb, 0xca, 0xa7, 0x27, 0x4a, 0xb3, 0x4a, 0x54, 0x4c, 0xc3, 0xaa,
	0x5a, 0xef, 0x76, 0x94, 0xc7, 0x1d, 0x49, 0x0c, 0x16, 0xc7, 0xea, 0xa9, 0x22, 0xc5, 0x76, 0x9b,
	0xb0, 0xc6, 0x0e, 0xff, 0x04, 0x49, 0xe3, 0x91, 0x34, 0x06, 0x49, 0x24, 0xaa, 0x69, 0xf5, 0xae,
	0x7a, 0xd4, 0xd4, 0x74, 0xa5, 0xfb, 0x50, 0x79, 0x22, 0xc5, 0x08, 0x9e, 0x16, 0xe0, 0xc5, 0x77,
	0xab, 0x90, 0x9a, 0x4f, 0x59, 0x84, 0xb9, 0xd3, 0x79, 0xd2, 0x52, 0xba, 0x8f, 0x2a, 0xcd, 0xca,
	0x91, 0x52, 0x93, 0xee, 0x20, 0x04, 0x59, 0x9f, 0xa4, 0x3c, 0xf6, 0xef, 0xe2, 0x24, 0x81, 0x08,
	0xf1, 0x69, 0x6a, 0xb3, 0xa6, 0x3c, 0x96, 0xc4, 0xdd, 0xf7, 0x40, 0x6a, 0x2f, 0x7e, 0x44, 0x12,
	0x07, 0x34, 0x42, 0xc5, 0x10, 0x64, 0xdb, 0x0d, 0x3e, 0x10, 0xe5, 0x7f, 0xa6, 0x20, 0xf5, 0x68,
	0x96, 0x09, 0x48, 0x87, 0xec, 0xec, 0xce, 0xa8, 0x67, 0x78, 0x86, 0x8b, 0x11, 0x3b, 0xd5, 0x45,
	0x5e, 0x27, 0xe5, 0xef, 0x33, 0x1c, 0x51, 0x57, 0x1e, 0x13, 0x48, 0x33, 0x64, 0x74, 0x6f, 0x19,
	0xfb, 0xb5, 0xd0, 0x64, 0xf9, 0x17, 0x7f, 0xfd, 0xc7, 0x6f, 0xc4, 0x1d, 0x94, 0x2f, 0xbd, 0x28,
	0x97, 0xcc, 0x5e, 0xe9, 0xab, 0xe0, 0x18, 0xbc, 0x2c, 0x7d, 0x65, 0x99, 0xfb, 0xe4, 0x33, 0xfb,
	0x25, 0x32, 0x20, 0xc3, 0x5d, 0x80, 0x20, 0xf6, 0xca, 0x35, 0xea, 0x6a, 0x24, 0x1f, 0x75, 0x09,
	0x23, 0xe7, 0xa8, 0x28, 0x84, 0xa4, 0x45, 0x51, 0x07, 0x02, 0x3a, 0x86, 0x35, 0xf6, 0x3e, 0x03,
	0xb1, 0x6a, 0x47, 0x5c, 0x74, 0xe4, 0x97, 0xd6, 0x2a, 0xd4, 0x82, 0x0c, 0x77, 0x53, 0xc6, 0x29,
	0x1b, 0x75, 0x87, 0x76, 0xa5, 0xc3, 0x55, 0x48, 0x33, 0x43, 0x26, 0xe7, 0xf0, 0x8b, 0xc3, 0x67,
	0xfe, 0x4d, 0x1e, 0x8d, 0x1f, 0xbf, 0x3e, 0x87, 0xe4, 0x8c, 0x86, 0xf2, 0x91, 0x8c, 0x57, 0x83,
	0xc8, 0x65, 0xea, 0xc7, 0x3d, 0xb4, 0x4b, 0xfc, 0x48, 0xeb, 0x0c, 0x1b, 0x35, 0x5a, 0xbb, 0xfc,
	0xc0, 0x31, 0x21, 0x3c, 0x03, 0x08, 0x87, 0x33, 0xb4, 0xb3, 0x10, 0x3f, 0x6e, 0x66, 0xcb, 0x5f,
	0x18, 0x0a, 0xe5, 0x22, 0x95, 0x28, 0xa3, 0xc2, 0x55, 0x12, 0x0f, 0x04, 0x74, 0x08, 0xa9, 0xf9,
	0x08, 0x86, 0xde, 0x5c, 0x08, 0x23, 0x67, 0xe4, 0xf2, 0x18, 0x1e, 0xc3, 0x1a, 0x3b, 0x30, 0x70,
	0xd9, 0x10, 0x31, 0x49, 0x5c, 0x82, 0xf4, 0x6b, 0x01, 0xd6, 0xd8, 0x86, 0x89, 0x16, 0x82, 0x7d,
	0x01, 0xea, 0xad, 0xa5, 0xfb, 0x81, 0xf7, 0x3f, 0xa4, 0xbe, 0xf8, 0x31, 0xfa, 0x11, 0xf1, 0xc5,
	0xbc, 0x99, 0x2e, 0x8d, 0xc0, 0xac, 0x4d, 0x04, 0x71, 0xf8, 0x5a, 0x80, 0x2c, 0xdf, 0x41, 0xb9,
	0x8a, 0x10, 0xd9, 0x5c, 0xf3, 0x91, 0x9d, 0x5c, 0xfe, 0x88, 0x2a, 0xf2, 0x00, 0xbd, 0xc7, 0x29,
	0xe2, 0x5e, 0x53, 0x93, 0x03, 0x01, 0x7d, 0x02, 0x19, 0xae, 0x35, 0x72, 0x27, 0x25, 0xaa, 0x69,
	0x2e, 0xf7, 0xf3, 0xe1, 0xdf, 0x84, 0x57, 0x95, 0xbf, 0x08, 0xe8, 0x33, 0x40, 0xc7, 0xd6, 0x0b,
	0x5c, 0x98, 0x57, 0xc0, 0x42, 0x65, 0x62, 0xc9, 0x1a, 0xdc, 0x5d, 0xa0, 0xb6, 0x1c, 0xfb, 0x33,
	0xdc, 0xf7, 0x90, 0x7c, 0xe6, 0x79, 0x13, 0xf7, 0x83, 0x52, 0x69, 0x60, 0x79, 0x67, 0xd3, 0xde,
	0x7e, 0xdf, 0x1e, 0x95, 0x8c, 0x67, 0xf6, 0xb0, 0xf7, 0x6e, 0xe9, 0x6c, 0xe4, 0xbe, 0x28, 0x1b,
	0x13, 0x2b, 0xbf, 0xe1, 0x13, 0x3e, 0xf6, 0xff, 0x54, 0x22, 0x2c, 0xe5, 0xd8, 0xbb, 0xfb, 0x07,
	0x4e, 0x0d, 0xee, 0x33, 0x62, 0x5a, 0x6a, 0xe1, 0xb4, 0x5c, 0xa8, 0xd9, 0xfd, 0xe9, 0x08, 0x8f,
	0xfd, 0xbf, 0x90, 0xae, 0x83, 0x0e, 0x9b, 0x7d, 0x7b, 0xb4, 0x4f, 0x89, 0xa1, 0x6d, 0x87, 0xb4,
	0x82, 0x93, 0x69, 0x1b, 0xb7, 0x84, 0xde, 0x0a, 0xfd, 0x23, 0xea, 0x87, 0xff, 0x0e, 0x00, 0x00,
	0xff, 0xff, 0x18, 0xfe, 0x6c, 0x2b, 0xf2, 0x1a, 0x00, 0x00,
}
