// Code generated by protoc-gen-go. DO NOT EDIT.
// source: metastore.proto

/*
Package metastore is a generated protocol buffer package.

It is generated from these files:
	metastore.proto

It has these top-level messages:
	RequestStatus
	Id
	Database
	CreateDatabaseRequest
	GetDatabaseRequest
	GetDatabaseResponse
	ListDatabasesRequest
	DropDatabaseRequest
	FieldSchema
	SerDeInfo
	Order
	StorageDescriptor
	Table
	CreateTableRequest
	GetTableRequest
	GetTableResponse
	ListTablesRequest
	DropTableRequest
*/
package metastore

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Known SerDes are represented using enum. Unknown ones are represented using strings.
type SerdeType int32

const (
	SerdeType_SERDE_CUSTOM      SerdeType = 0
	SerdeType_SERDE_LAZY_SIMPLE SerdeType = 1
	SerdeType_SERDE_AVRO        SerdeType = 2
	SerdeType_SERDE_JSON        SerdeType = 3
	SerdeType_SERDE_ORC         SerdeType = 4
	SerdeType_SERDE_REGEX       SerdeType = 5
	SerdeType_SERDE_THRIFT      SerdeType = 6
	SerdeType_SERDE_PARQUET     SerdeType = 7
	SerdeType_SERDE_CSV         SerdeType = 8
)

var SerdeType_name = map[int32]string{
	0: "SERDE_CUSTOM",
	1: "SERDE_LAZY_SIMPLE",
	2: "SERDE_AVRO",
	3: "SERDE_JSON",
	4: "SERDE_ORC",
	5: "SERDE_REGEX",
	6: "SERDE_THRIFT",
	7: "SERDE_PARQUET",
	8: "SERDE_CSV",
}
var SerdeType_value = map[string]int32{
	"SERDE_CUSTOM":      0,
	"SERDE_LAZY_SIMPLE": 1,
	"SERDE_AVRO":        2,
	"SERDE_JSON":        3,
	"SERDE_ORC":         4,
	"SERDE_REGEX":       5,
	"SERDE_THRIFT":      6,
	"SERDE_PARQUET":     7,
	"SERDE_CSV":         8,
}

func (x SerdeType) String() string {
	return proto.EnumName(SerdeType_name, int32(x))
}
func (SerdeType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Known Input Formats. CUSTOM means that it should be specified as a string.
type InputFormat int32

const (
	InputFormat_IF_CUSTOM   InputFormat = 0
	InputFormat_IF_SEQUENCE InputFormat = 1
	InputFormat_IF_TEXT     InputFormat = 2
	InputFormat_IF_HIVE     InputFormat = 3
)

var InputFormat_name = map[int32]string{
	0: "IF_CUSTOM",
	1: "IF_SEQUENCE",
	2: "IF_TEXT",
	3: "IF_HIVE",
}
var InputFormat_value = map[string]int32{
	"IF_CUSTOM":   0,
	"IF_SEQUENCE": 1,
	"IF_TEXT":     2,
	"IF_HIVE":     3,
}

func (x InputFormat) String() string {
	return proto.EnumName(InputFormat_name, int32(x))
}
func (InputFormat) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// Known Output Formats. CUSTOM means that it should be specified as a string.
type OutputFormat int32

const (
	OutputFormat_OF_CUSTOM     OutputFormat = 0
	OutputFormat_OF_SEQUENCE   OutputFormat = 2
	OutputFormat_OF_IGNORE_KEY OutputFormat = 3
	OutputFormat_OF_HIVE       OutputFormat = 4
)

var OutputFormat_name = map[int32]string{
	0: "OF_CUSTOM",
	2: "OF_SEQUENCE",
	3: "OF_IGNORE_KEY",
	4: "OF_HIVE",
}
var OutputFormat_value = map[string]int32{
	"OF_CUSTOM":     0,
	"OF_SEQUENCE":   2,
	"OF_IGNORE_KEY": 3,
	"OF_HIVE":       4,
}

func (x OutputFormat) String() string {
	return proto.EnumName(OutputFormat_name, int32(x))
}
func (OutputFormat) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type TableType int32

const (
	TableType_TTYPE_MANAGED  TableType = 0
	TableType_TTYPE_EXTERNAL TableType = 1
	TableType_TTYPE_INDEX    TableType = 2
)

var TableType_name = map[int32]string{
	0: "TTYPE_MANAGED",
	1: "TTYPE_EXTERNAL",
	2: "TTYPE_INDEX",
}
var TableType_value = map[string]int32{
	"TTYPE_MANAGED":  0,
	"TTYPE_EXTERNAL": 1,
	"TTYPE_INDEX":    2,
}

func (x TableType) String() string {
	return proto.EnumName(TableType_name, int32(x))
}
func (TableType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type RequestStatus_Status int32

const (
	RequestStatus_OK       RequestStatus_Status = 0
	RequestStatus_ERROR    RequestStatus_Status = 1
	RequestStatus_NOTFOUND RequestStatus_Status = 2
	RequestStatus_CONFLICT RequestStatus_Status = 3
	RequestStatus_BUSY     RequestStatus_Status = 4
	RequestStatus_INTERNAL RequestStatus_Status = 5
)

var RequestStatus_Status_name = map[int32]string{
	0: "OK",
	1: "ERROR",
	2: "NOTFOUND",
	3: "CONFLICT",
	4: "BUSY",
	5: "INTERNAL",
}
var RequestStatus_Status_value = map[string]int32{
	"OK":       0,
	"ERROR":    1,
	"NOTFOUND": 2,
	"CONFLICT": 3,
	"BUSY":     4,
	"INTERNAL": 5,
}

func (x RequestStatus_Status) String() string {
	return proto.EnumName(RequestStatus_Status_name, int32(x))
}
func (RequestStatus_Status) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

// General status for results
type RequestStatus struct {
	Status RequestStatus_Status `protobuf:"varint,1,opt,name=status,enum=metastore.RequestStatus_Status" json:"status,omitempty"`
	Error  string               `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
	Cookie string               `protobuf:"bytes,3,opt,name=cookie" json:"cookie,omitempty"`
}

func (m *RequestStatus) Reset()                    { *m = RequestStatus{} }
func (m *RequestStatus) String() string            { return proto.CompactTextString(m) }
func (*RequestStatus) ProtoMessage()               {}
func (*RequestStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *RequestStatus) GetStatus() RequestStatus_Status {
	if m != nil {
		return m.Status
	}
	return RequestStatus_OK
}

func (m *RequestStatus) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *RequestStatus) GetCookie() string {
	if m != nil {
		return m.Cookie
	}
	return ""
}

// Objects have unique name and unique ID.
// Both name and ID are just sequence of bytes - there are no
// assumptions about encoding or length.
type Id struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Id   string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
}

func (m *Id) Reset()                    { *m = Id{} }
func (m *Id) String() string            { return proto.CompactTextString(m) }
func (*Id) ProtoMessage()               {}
func (*Id) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Id) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Id) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// Database is a container for tables.
// Database object has two sets of parameters:
//  - User parameters are intended for user and are just transparently passed around
//  - System parameters are intended to be used by Hive for its internal purposes
//
// seq_id is a numeric ID which is unique within a catalog. It can be used to track
// new databases in the catalog
//
// Original Metastore Database object also had owner information.
// These can be represented using system parameters if needed since the current
// metastore service does not interpret Owner info.
type Database struct {
	Id               *Id               `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	SeqId            uint64            `protobuf:"varint,2,opt,name=seq_id,json=seqId" json:"seq_id,omitempty"`
	Location         string            `protobuf:"bytes,3,opt,name=location" json:"location,omitempty"`
	Parameters       map[string]string `protobuf:"bytes,4,rep,name=parameters" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	SystemParameters map[string]string `protobuf:"bytes,5,rep,name=system_parameters,json=systemParameters" json:"system_parameters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Database) Reset()                    { *m = Database{} }
func (m *Database) String() string            { return proto.CompactTextString(m) }
func (*Database) ProtoMessage()               {}
func (*Database) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Database) GetId() *Id {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Database) GetSeqId() uint64 {
	if m != nil {
		return m.SeqId
	}
	return 0
}

func (m *Database) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func (m *Database) GetParameters() map[string]string {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *Database) GetSystemParameters() map[string]string {
	if m != nil {
		return m.SystemParameters
	}
	return nil
}

// Create a new database.
type CreateDatabaseRequest struct {
	Catalog  string    `protobuf:"bytes,1,opt,name=catalog" json:"catalog,omitempty"`
	Database *Database `protobuf:"bytes,2,opt,name=database" json:"database,omitempty"`
	Cookie   string    `protobuf:"bytes,3,opt,name=cookie" json:"cookie,omitempty"`
}

func (m *CreateDatabaseRequest) Reset()                    { *m = CreateDatabaseRequest{} }
func (m *CreateDatabaseRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateDatabaseRequest) ProtoMessage()               {}
func (*CreateDatabaseRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *CreateDatabaseRequest) GetCatalog() string {
	if m != nil {
		return m.Catalog
	}
	return ""
}

func (m *CreateDatabaseRequest) GetDatabase() *Database {
	if m != nil {
		return m.Database
	}
	return nil
}

func (m *CreateDatabaseRequest) GetCookie() string {
	if m != nil {
		return m.Cookie
	}
	return ""
}

// Request to get database by its ID.
type GetDatabaseRequest struct {
	Catalog string `protobuf:"bytes,1,opt,name=catalog" json:"catalog,omitempty"`
	Id      *Id    `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	Cookie  string `protobuf:"bytes,3,opt,name=cookie" json:"cookie,omitempty"`
}

func (m *GetDatabaseRequest) Reset()                    { *m = GetDatabaseRequest{} }
func (m *GetDatabaseRequest) String() string            { return proto.CompactTextString(m) }
func (*GetDatabaseRequest) ProtoMessage()               {}
func (*GetDatabaseRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *GetDatabaseRequest) GetCatalog() string {
	if m != nil {
		return m.Catalog
	}
	return ""
}

func (m *GetDatabaseRequest) GetId() *Id {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *GetDatabaseRequest) GetCookie() string {
	if m != nil {
		return m.Cookie
	}
	return ""
}

type GetDatabaseResponse struct {
	Database *Database      `protobuf:"bytes,1,opt,name=database" json:"database,omitempty"`
	Status   *RequestStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *GetDatabaseResponse) Reset()                    { *m = GetDatabaseResponse{} }
func (m *GetDatabaseResponse) String() string            { return proto.CompactTextString(m) }
func (*GetDatabaseResponse) ProtoMessage()               {}
func (*GetDatabaseResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *GetDatabaseResponse) GetDatabase() *Database {
	if m != nil {
		return m.Database
	}
	return nil
}

func (m *GetDatabaseResponse) GetStatus() *RequestStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// Request to get list of databases
// If exclude_params is set, result may omit parameters
type ListDatabasesRequest struct {
	Catalog       string `protobuf:"bytes,1,opt,name=catalog" json:"catalog,omitempty"`
	Cookie        string `protobuf:"bytes,2,opt,name=cookie" json:"cookie,omitempty"`
	NamePattern   string `protobuf:"bytes,3,opt,name=name_pattern,json=namePattern" json:"name_pattern,omitempty"`
	ExcludeParams bool   `protobuf:"varint,4,opt,name=exclude_params,json=excludeParams" json:"exclude_params,omitempty"`
}

func (m *ListDatabasesRequest) Reset()                    { *m = ListDatabasesRequest{} }
func (m *ListDatabasesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListDatabasesRequest) ProtoMessage()               {}
func (*ListDatabasesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ListDatabasesRequest) GetCatalog() string {
	if m != nil {
		return m.Catalog
	}
	return ""
}

func (m *ListDatabasesRequest) GetCookie() string {
	if m != nil {
		return m.Cookie
	}
	return ""
}

func (m *ListDatabasesRequest) GetNamePattern() string {
	if m != nil {
		return m.NamePattern
	}
	return ""
}

func (m *ListDatabasesRequest) GetExcludeParams() bool {
	if m != nil {
		return m.ExcludeParams
	}
	return false
}

// Request to drop a database.
// Dropping a database also drops all objects contained in the database.
// TODO: Add flag to prohibit dropping non-empty databases
type DropDatabaseRequest struct {
	Catalog string `protobuf:"bytes,1,opt,name=catalog" json:"catalog,omitempty"`
	Id      *Id    `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	Cookie  string `protobuf:"bytes,3,opt,name=cookie" json:"cookie,omitempty"`
}

func (m *DropDatabaseRequest) Reset()                    { *m = DropDatabaseRequest{} }
func (m *DropDatabaseRequest) String() string            { return proto.CompactTextString(m) }
func (*DropDatabaseRequest) ProtoMessage()               {}
func (*DropDatabaseRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *DropDatabaseRequest) GetCatalog() string {
	if m != nil {
		return m.Catalog
	}
	return ""
}

func (m *DropDatabaseRequest) GetId() *Id {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *DropDatabaseRequest) GetCookie() string {
	if m != nil {
		return m.Cookie
	}
	return ""
}

// FieldSchema defines name and type for each column.
type FieldSchema struct {
	Name    string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Type    string `protobuf:"bytes,2,opt,name=type" json:"type,omitempty"`
	Comment string `protobuf:"bytes,3,opt,name=comment" json:"comment,omitempty"`
}

func (m *FieldSchema) Reset()                    { *m = FieldSchema{} }
func (m *FieldSchema) String() string            { return proto.CompactTextString(m) }
func (*FieldSchema) ProtoMessage()               {}
func (*FieldSchema) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *FieldSchema) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FieldSchema) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *FieldSchema) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

// Serialization/Deserialization information
type SerDeInfo struct {
	Type             SerdeType `protobuf:"varint,1,opt,name=type,enum=metastore.SerdeType" json:"type,omitempty"`
	Name             string    `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	SerializationLib string    `protobuf:"bytes,3,opt,name=serializationLib" json:"serializationLib,omitempty"`
	// NOTE: Should we enum this as well?
	Parameters map[string]string `protobuf:"bytes,4,rep,name=parameters" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *SerDeInfo) Reset()                    { *m = SerDeInfo{} }
func (m *SerDeInfo) String() string            { return proto.CompactTextString(m) }
func (*SerDeInfo) ProtoMessage()               {}
func (*SerDeInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *SerDeInfo) GetType() SerdeType {
	if m != nil {
		return m.Type
	}
	return SerdeType_SERDE_CUSTOM
}

func (m *SerDeInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SerDeInfo) GetSerializationLib() string {
	if m != nil {
		return m.SerializationLib
	}
	return ""
}

func (m *SerDeInfo) GetParameters() map[string]string {
	if m != nil {
		return m.Parameters
	}
	return nil
}

// sort order of a column (column name along with asc/desc)
type Order struct {
	Col       string `protobuf:"bytes,1,opt,name=col" json:"col,omitempty"`
	Ascending bool   `protobuf:"varint,2,opt,name=ascending" json:"ascending,omitempty"`
}

func (m *Order) Reset()                    { *m = Order{} }
func (m *Order) String() string            { return proto.CompactTextString(m) }
func (*Order) ProtoMessage()               {}
func (*Order) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *Order) GetCol() string {
	if m != nil {
		return m.Col
	}
	return ""
}

func (m *Order) GetAscending() bool {
	if m != nil {
		return m.Ascending
	}
	return false
}

// StorageDescriptor holds all the information about physical storage of the data belonging to a table
type StorageDescriptor struct {
	Cols             []*FieldSchema    `protobuf:"bytes,1,rep,name=cols" json:"cols,omitempty"`
	Location         string            `protobuf:"bytes,2,opt,name=location" json:"location,omitempty"`
	InputFormat      InputFormat       `protobuf:"varint,3,opt,name=inputFormat,enum=metastore.InputFormat" json:"inputFormat,omitempty"`
	InputFormatName  string            `protobuf:"bytes,4,opt,name=inputFormatName" json:"inputFormatName,omitempty"`
	OutputFormat     OutputFormat      `protobuf:"varint,5,opt,name=outputFormat,enum=metastore.OutputFormat" json:"outputFormat,omitempty"`
	OutputFormatName string            `protobuf:"bytes,6,opt,name=outputFormatName" json:"outputFormatName,omitempty"`
	NumBuckets       int32             `protobuf:"varint,7,opt,name=numBuckets" json:"numBuckets,omitempty"`
	SerdeInfo        *SerDeInfo        `protobuf:"bytes,8,opt,name=serdeInfo" json:"serdeInfo,omitempty"`
	BucketCols       []string          `protobuf:"bytes,9,rep,name=bucketCols" json:"bucketCols,omitempty"`
	SortCols         []*Order          `protobuf:"bytes,10,rep,name=sortCols" json:"sortCols,omitempty"`
	Parameters       map[string]string `protobuf:"bytes,11,rep,name=parameters" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	SystemParameters map[string]string `protobuf:"bytes,12,rep,name=system_parameters,json=systemParameters" json:"system_parameters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *StorageDescriptor) Reset()                    { *m = StorageDescriptor{} }
func (m *StorageDescriptor) String() string            { return proto.CompactTextString(m) }
func (*StorageDescriptor) ProtoMessage()               {}
func (*StorageDescriptor) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *StorageDescriptor) GetCols() []*FieldSchema {
	if m != nil {
		return m.Cols
	}
	return nil
}

func (m *StorageDescriptor) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func (m *StorageDescriptor) GetInputFormat() InputFormat {
	if m != nil {
		return m.InputFormat
	}
	return InputFormat_IF_CUSTOM
}

func (m *StorageDescriptor) GetInputFormatName() string {
	if m != nil {
		return m.InputFormatName
	}
	return ""
}

func (m *StorageDescriptor) GetOutputFormat() OutputFormat {
	if m != nil {
		return m.OutputFormat
	}
	return OutputFormat_OF_CUSTOM
}

func (m *StorageDescriptor) GetOutputFormatName() string {
	if m != nil {
		return m.OutputFormatName
	}
	return ""
}

func (m *StorageDescriptor) GetNumBuckets() int32 {
	if m != nil {
		return m.NumBuckets
	}
	return 0
}

func (m *StorageDescriptor) GetSerdeInfo() *SerDeInfo {
	if m != nil {
		return m.SerdeInfo
	}
	return nil
}

func (m *StorageDescriptor) GetBucketCols() []string {
	if m != nil {
		return m.BucketCols
	}
	return nil
}

func (m *StorageDescriptor) GetSortCols() []*Order {
	if m != nil {
		return m.SortCols
	}
	return nil
}

func (m *StorageDescriptor) GetParameters() map[string]string {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *StorageDescriptor) GetSystemParameters() map[string]string {
	if m != nil {
		return m.SystemParameters
	}
	return nil
}

// Table information
type Table struct {
	Id               *Id                `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	SeqId            uint64             `protobuf:"varint,3,opt,name=seq_id,json=seqId" json:"seq_id,omitempty"`
	Sd               *StorageDescriptor `protobuf:"bytes,4,opt,name=sd" json:"sd,omitempty"`
	PartitionKeys    []*FieldSchema     `protobuf:"bytes,5,rep,name=partitionKeys" json:"partitionKeys,omitempty"`
	TableType        TableType          `protobuf:"varint,6,opt,name=tableType,enum=metastore.TableType" json:"tableType,omitempty"`
	Parameters       map[string]string  `protobuf:"bytes,7,rep,name=parameters" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	SystemParameters map[string]string  `protobuf:"bytes,8,rep,name=system_parameters,json=systemParameters" json:"system_parameters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Table) Reset()                    { *m = Table{} }
func (m *Table) String() string            { return proto.CompactTextString(m) }
func (*Table) ProtoMessage()               {}
func (*Table) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *Table) GetId() *Id {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Table) GetSeqId() uint64 {
	if m != nil {
		return m.SeqId
	}
	return 0
}

func (m *Table) GetSd() *StorageDescriptor {
	if m != nil {
		return m.Sd
	}
	return nil
}

func (m *Table) GetPartitionKeys() []*FieldSchema {
	if m != nil {
		return m.PartitionKeys
	}
	return nil
}

func (m *Table) GetTableType() TableType {
	if m != nil {
		return m.TableType
	}
	return TableType_TTYPE_MANAGED
}

func (m *Table) GetParameters() map[string]string {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *Table) GetSystemParameters() map[string]string {
	if m != nil {
		return m.SystemParameters
	}
	return nil
}

// Create a new table.
type CreateTableRequest struct {
	Catalog string `protobuf:"bytes,1,opt,name=catalog" json:"catalog,omitempty"`
	DbId    *Id    `protobuf:"bytes,2,opt,name=db_id,json=dbId" json:"db_id,omitempty"`
	Table   *Table `protobuf:"bytes,3,opt,name=table" json:"table,omitempty"`
	Cookie  string `protobuf:"bytes,4,opt,name=cookie" json:"cookie,omitempty"`
}

func (m *CreateTableRequest) Reset()                    { *m = CreateTableRequest{} }
func (m *CreateTableRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateTableRequest) ProtoMessage()               {}
func (*CreateTableRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *CreateTableRequest) GetCatalog() string {
	if m != nil {
		return m.Catalog
	}
	return ""
}

func (m *CreateTableRequest) GetDbId() *Id {
	if m != nil {
		return m.DbId
	}
	return nil
}

func (m *CreateTableRequest) GetTable() *Table {
	if m != nil {
		return m.Table
	}
	return nil
}

func (m *CreateTableRequest) GetCookie() string {
	if m != nil {
		return m.Cookie
	}
	return ""
}

// Request to get table by its ID.
type GetTableRequest struct {
	Catalog string `protobuf:"bytes,1,opt,name=catalog" json:"catalog,omitempty"`
	DbId    *Id    `protobuf:"bytes,2,opt,name=db_id,json=dbId" json:"db_id,omitempty"`
	Id      *Id    `protobuf:"bytes,3,opt,name=id" json:"id,omitempty"`
	Cookie  string `protobuf:"bytes,4,opt,name=cookie" json:"cookie,omitempty"`
}

func (m *GetTableRequest) Reset()                    { *m = GetTableRequest{} }
func (m *GetTableRequest) String() string            { return proto.CompactTextString(m) }
func (*GetTableRequest) ProtoMessage()               {}
func (*GetTableRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *GetTableRequest) GetCatalog() string {
	if m != nil {
		return m.Catalog
	}
	return ""
}

func (m *GetTableRequest) GetDbId() *Id {
	if m != nil {
		return m.DbId
	}
	return nil
}

func (m *GetTableRequest) GetId() *Id {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *GetTableRequest) GetCookie() string {
	if m != nil {
		return m.Cookie
	}
	return ""
}

type GetTableResponse struct {
	Table  *Table         `protobuf:"bytes,1,opt,name=table" json:"table,omitempty"`
	Status *RequestStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *GetTableResponse) Reset()                    { *m = GetTableResponse{} }
func (m *GetTableResponse) String() string            { return proto.CompactTextString(m) }
func (*GetTableResponse) ProtoMessage()               {}
func (*GetTableResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *GetTableResponse) GetTable() *Table {
	if m != nil {
		return m.Table
	}
	return nil
}

func (m *GetTableResponse) GetStatus() *RequestStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// Request to get list of databases
// If exclude_params is set, result may omit parameters
type ListTablesRequest struct {
	Catalog string `protobuf:"bytes,1,opt,name=catalog" json:"catalog,omitempty"`
	DbId    *Id    `protobuf:"bytes,2,opt,name=db_id,json=dbId" json:"db_id,omitempty"`
	Cookie  string `protobuf:"bytes,3,opt,name=cookie" json:"cookie,omitempty"`
}

func (m *ListTablesRequest) Reset()                    { *m = ListTablesRequest{} }
func (m *ListTablesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListTablesRequest) ProtoMessage()               {}
func (*ListTablesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *ListTablesRequest) GetCatalog() string {
	if m != nil {
		return m.Catalog
	}
	return ""
}

func (m *ListTablesRequest) GetDbId() *Id {
	if m != nil {
		return m.DbId
	}
	return nil
}

func (m *ListTablesRequest) GetCookie() string {
	if m != nil {
		return m.Cookie
	}
	return ""
}

// Request to drop a table.
// Dropping a table also drops all objects contained in the table
// TODO: Add flag to prohibit dropping of non-empty table
type DropTableRequest struct {
	Catalog string `protobuf:"bytes,1,opt,name=catalog" json:"catalog,omitempty"`
	DbId    *Id    `protobuf:"bytes,2,opt,name=db_id,json=dbId" json:"db_id,omitempty"`
	Id      *Id    `protobuf:"bytes,3,opt,name=id" json:"id,omitempty"`
	Cookie  string `protobuf:"bytes,4,opt,name=cookie" json:"cookie,omitempty"`
}

func (m *DropTableRequest) Reset()                    { *m = DropTableRequest{} }
func (m *DropTableRequest) String() string            { return proto.CompactTextString(m) }
func (*DropTableRequest) ProtoMessage()               {}
func (*DropTableRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *DropTableRequest) GetCatalog() string {
	if m != nil {
		return m.Catalog
	}
	return ""
}

func (m *DropTableRequest) GetDbId() *Id {
	if m != nil {
		return m.DbId
	}
	return nil
}

func (m *DropTableRequest) GetId() *Id {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *DropTableRequest) GetCookie() string {
	if m != nil {
		return m.Cookie
	}
	return ""
}

func init() {
	proto.RegisterType((*RequestStatus)(nil), "metastore.RequestStatus")
	proto.RegisterType((*Id)(nil), "metastore.Id")
	proto.RegisterType((*Database)(nil), "metastore.Database")
	proto.RegisterType((*CreateDatabaseRequest)(nil), "metastore.CreateDatabaseRequest")
	proto.RegisterType((*GetDatabaseRequest)(nil), "metastore.GetDatabaseRequest")
	proto.RegisterType((*GetDatabaseResponse)(nil), "metastore.GetDatabaseResponse")
	proto.RegisterType((*ListDatabasesRequest)(nil), "metastore.ListDatabasesRequest")
	proto.RegisterType((*DropDatabaseRequest)(nil), "metastore.DropDatabaseRequest")
	proto.RegisterType((*FieldSchema)(nil), "metastore.FieldSchema")
	proto.RegisterType((*SerDeInfo)(nil), "metastore.SerDeInfo")
	proto.RegisterType((*Order)(nil), "metastore.Order")
	proto.RegisterType((*StorageDescriptor)(nil), "metastore.StorageDescriptor")
	proto.RegisterType((*Table)(nil), "metastore.Table")
	proto.RegisterType((*CreateTableRequest)(nil), "metastore.CreateTableRequest")
	proto.RegisterType((*GetTableRequest)(nil), "metastore.GetTableRequest")
	proto.RegisterType((*GetTableResponse)(nil), "metastore.GetTableResponse")
	proto.RegisterType((*ListTablesRequest)(nil), "metastore.ListTablesRequest")
	proto.RegisterType((*DropTableRequest)(nil), "metastore.DropTableRequest")
	proto.RegisterEnum("metastore.SerdeType", SerdeType_name, SerdeType_value)
	proto.RegisterEnum("metastore.InputFormat", InputFormat_name, InputFormat_value)
	proto.RegisterEnum("metastore.OutputFormat", OutputFormat_name, OutputFormat_value)
	proto.RegisterEnum("metastore.TableType", TableType_name, TableType_value)
	proto.RegisterEnum("metastore.RequestStatus_Status", RequestStatus_Status_name, RequestStatus_Status_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Metastore service

type MetastoreClient interface {
	// Create a new database
	CreateDabatase(ctx context.Context, in *CreateDatabaseRequest, opts ...grpc.CallOption) (*GetDatabaseResponse, error)
	// Get database information
	GetDatabase(ctx context.Context, in *GetDatabaseRequest, opts ...grpc.CallOption) (*GetDatabaseResponse, error)
	// Get collection of databases
	ListDatabases(ctx context.Context, in *ListDatabasesRequest, opts ...grpc.CallOption) (Metastore_ListDatabasesClient, error)
	// Destroy a database
	DropDatabase(ctx context.Context, in *DropDatabaseRequest, opts ...grpc.CallOption) (*RequestStatus, error)
	// Create a new table
	CreateTable(ctx context.Context, in *CreateTableRequest, opts ...grpc.CallOption) (*GetTableResponse, error)
	// Get table information
	GetTable(ctx context.Context, in *GetTableRequest, opts ...grpc.CallOption) (*GetTableResponse, error)
	// Get collection of tables
	ListTables(ctx context.Context, in *ListTablesRequest, opts ...grpc.CallOption) (Metastore_ListTablesClient, error)
	// Destroy a table
	DropTable(ctx context.Context, in *DropTableRequest, opts ...grpc.CallOption) (*RequestStatus, error)
}

type metastoreClient struct {
	cc *grpc.ClientConn
}

func NewMetastoreClient(cc *grpc.ClientConn) MetastoreClient {
	return &metastoreClient{cc}
}

func (c *metastoreClient) CreateDabatase(ctx context.Context, in *CreateDatabaseRequest, opts ...grpc.CallOption) (*GetDatabaseResponse, error) {
	out := new(GetDatabaseResponse)
	err := grpc.Invoke(ctx, "/metastore.Metastore/CreateDabatase", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metastoreClient) GetDatabase(ctx context.Context, in *GetDatabaseRequest, opts ...grpc.CallOption) (*GetDatabaseResponse, error) {
	out := new(GetDatabaseResponse)
	err := grpc.Invoke(ctx, "/metastore.Metastore/GetDatabase", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metastoreClient) ListDatabases(ctx context.Context, in *ListDatabasesRequest, opts ...grpc.CallOption) (Metastore_ListDatabasesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Metastore_serviceDesc.Streams[0], c.cc, "/metastore.Metastore/ListDatabases", opts...)
	if err != nil {
		return nil, err
	}
	x := &metastoreListDatabasesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Metastore_ListDatabasesClient interface {
	Recv() (*Database, error)
	grpc.ClientStream
}

type metastoreListDatabasesClient struct {
	grpc.ClientStream
}

func (x *metastoreListDatabasesClient) Recv() (*Database, error) {
	m := new(Database)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *metastoreClient) DropDatabase(ctx context.Context, in *DropDatabaseRequest, opts ...grpc.CallOption) (*RequestStatus, error) {
	out := new(RequestStatus)
	err := grpc.Invoke(ctx, "/metastore.Metastore/DropDatabase", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metastoreClient) CreateTable(ctx context.Context, in *CreateTableRequest, opts ...grpc.CallOption) (*GetTableResponse, error) {
	out := new(GetTableResponse)
	err := grpc.Invoke(ctx, "/metastore.Metastore/CreateTable", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metastoreClient) GetTable(ctx context.Context, in *GetTableRequest, opts ...grpc.CallOption) (*GetTableResponse, error) {
	out := new(GetTableResponse)
	err := grpc.Invoke(ctx, "/metastore.Metastore/GetTable", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metastoreClient) ListTables(ctx context.Context, in *ListTablesRequest, opts ...grpc.CallOption) (Metastore_ListTablesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Metastore_serviceDesc.Streams[1], c.cc, "/metastore.Metastore/ListTables", opts...)
	if err != nil {
		return nil, err
	}
	x := &metastoreListTablesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Metastore_ListTablesClient interface {
	Recv() (*Table, error)
	grpc.ClientStream
}

type metastoreListTablesClient struct {
	grpc.ClientStream
}

func (x *metastoreListTablesClient) Recv() (*Table, error) {
	m := new(Table)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *metastoreClient) DropTable(ctx context.Context, in *DropTableRequest, opts ...grpc.CallOption) (*RequestStatus, error) {
	out := new(RequestStatus)
	err := grpc.Invoke(ctx, "/metastore.Metastore/DropTable", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Metastore service

type MetastoreServer interface {
	// Create a new database
	CreateDabatase(context.Context, *CreateDatabaseRequest) (*GetDatabaseResponse, error)
	// Get database information
	GetDatabase(context.Context, *GetDatabaseRequest) (*GetDatabaseResponse, error)
	// Get collection of databases
	ListDatabases(*ListDatabasesRequest, Metastore_ListDatabasesServer) error
	// Destroy a database
	DropDatabase(context.Context, *DropDatabaseRequest) (*RequestStatus, error)
	// Create a new table
	CreateTable(context.Context, *CreateTableRequest) (*GetTableResponse, error)
	// Get table information
	GetTable(context.Context, *GetTableRequest) (*GetTableResponse, error)
	// Get collection of tables
	ListTables(*ListTablesRequest, Metastore_ListTablesServer) error
	// Destroy a table
	DropTable(context.Context, *DropTableRequest) (*RequestStatus, error)
}

func RegisterMetastoreServer(s *grpc.Server, srv MetastoreServer) {
	s.RegisterService(&_Metastore_serviceDesc, srv)
}

func _Metastore_CreateDabatase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDatabaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetastoreServer).CreateDabatase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/metastore.Metastore/CreateDabatase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetastoreServer).CreateDabatase(ctx, req.(*CreateDatabaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Metastore_GetDatabase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDatabaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetastoreServer).GetDatabase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/metastore.Metastore/GetDatabase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetastoreServer).GetDatabase(ctx, req.(*GetDatabaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Metastore_ListDatabases_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListDatabasesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MetastoreServer).ListDatabases(m, &metastoreListDatabasesServer{stream})
}

type Metastore_ListDatabasesServer interface {
	Send(*Database) error
	grpc.ServerStream
}

type metastoreListDatabasesServer struct {
	grpc.ServerStream
}

func (x *metastoreListDatabasesServer) Send(m *Database) error {
	return x.ServerStream.SendMsg(m)
}

func _Metastore_DropDatabase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DropDatabaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetastoreServer).DropDatabase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/metastore.Metastore/DropDatabase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetastoreServer).DropDatabase(ctx, req.(*DropDatabaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Metastore_CreateTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetastoreServer).CreateTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/metastore.Metastore/CreateTable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetastoreServer).CreateTable(ctx, req.(*CreateTableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Metastore_GetTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetastoreServer).GetTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/metastore.Metastore/GetTable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetastoreServer).GetTable(ctx, req.(*GetTableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Metastore_ListTables_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListTablesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MetastoreServer).ListTables(m, &metastoreListTablesServer{stream})
}

type Metastore_ListTablesServer interface {
	Send(*Table) error
	grpc.ServerStream
}

type metastoreListTablesServer struct {
	grpc.ServerStream
}

func (x *metastoreListTablesServer) Send(m *Table) error {
	return x.ServerStream.SendMsg(m)
}

func _Metastore_DropTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DropTableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetastoreServer).DropTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/metastore.Metastore/DropTable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetastoreServer).DropTable(ctx, req.(*DropTableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Metastore_serviceDesc = grpc.ServiceDesc{
	ServiceName: "metastore.Metastore",
	HandlerType: (*MetastoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateDabatase",
			Handler:    _Metastore_CreateDabatase_Handler,
		},
		{
			MethodName: "GetDatabase",
			Handler:    _Metastore_GetDatabase_Handler,
		},
		{
			MethodName: "DropDatabase",
			Handler:    _Metastore_DropDatabase_Handler,
		},
		{
			MethodName: "CreateTable",
			Handler:    _Metastore_CreateTable_Handler,
		},
		{
			MethodName: "GetTable",
			Handler:    _Metastore_GetTable_Handler,
		},
		{
			MethodName: "DropTable",
			Handler:    _Metastore_DropTable_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListDatabases",
			Handler:       _Metastore_ListDatabases_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListTables",
			Handler:       _Metastore_ListTables_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "metastore.proto",
}

func init() { proto.RegisterFile("metastore.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1526 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x58, 0xdb, 0x6e, 0xdb, 0x46,
	0x13, 0x0e, 0xa9, 0x83, 0xa5, 0x91, 0x0f, 0xf4, 0xfa, 0xf0, 0x0b, 0x8a, 0x93, 0xdf, 0x65, 0xdb,
	0x40, 0x35, 0x0c, 0x2b, 0x50, 0x2f, 0x12, 0xf4, 0x84, 0xda, 0x12, 0xe5, 0xb0, 0x91, 0x45, 0x67,
	0x25, 0x1b, 0x76, 0x6f, 0x04, 0x4a, 0xdc, 0xb8, 0x84, 0x29, 0x51, 0x21, 0xa9, 0x34, 0x4e, 0x90,
	0x9b, 0x5e, 0xb4, 0xf7, 0xe9, 0x4b, 0xf4, 0x49, 0xda, 0x07, 0xe8, 0x2b, 0xf4, 0x21, 0x8a, 0x02,
	0x01, 0x8a, 0x5d, 0x92, 0xe2, 0x52, 0xa6, 0xec, 0x04, 0x4d, 0x51, 0xe4, 0x4a, 0x9c, 0xd9, 0xd9,
	0x6f, 0x8e, 0x3b, 0x3b, 0x2b, 0x58, 0x1a, 0x10, 0x4f, 0x77, 0x3d, 0xdb, 0x21, 0x3b, 0x23, 0xc7,
	0xf6, 0x6c, 0x94, 0x9f, 0x30, 0x4a, 0x1b, 0x67, 0xb6, 0x7d, 0x66, 0x91, 0x8a, 0x3e, 0x32, 0x2b,
	0xfa, 0x70, 0x68, 0x7b, 0xba, 0x67, 0xda, 0x43, 0xd7, 0x17, 0x94, 0x7f, 0x13, 0x60, 0x01, 0x93,
	0x27, 0x63, 0xe2, 0x7a, 0x6d, 0x4f, 0xf7, 0xc6, 0x2e, 0xba, 0x07, 0x59, 0x97, 0x7d, 0x15, 0x85,
	0x4d, 0xa1, 0xbc, 0x58, 0xfd, 0xff, 0x4e, 0x04, 0x1e, 0x93, 0xdc, 0xf1, 0x7f, 0x70, 0x20, 0x8e,
	0x56, 0x21, 0x43, 0x1c, 0xc7, 0x76, 0x8a, 0xe2, 0xa6, 0x50, 0xce, 0x63, 0x9f, 0x40, 0xeb, 0x90,
	0xed, 0xdb, 0xf6, 0xb9, 0x49, 0x8a, 0x29, 0xc6, 0x0e, 0x28, 0x59, 0x83, 0x6c, 0xa0, 0x30, 0x0b,
	0xa2, 0xf6, 0x50, 0xba, 0x81, 0xf2, 0x90, 0x51, 0x30, 0xd6, 0xb0, 0x24, 0xa0, 0x79, 0xc8, 0xb5,
	0xb4, 0x4e, 0x43, 0x3b, 0x6a, 0xd5, 0x25, 0x91, 0x52, 0x35, 0xad, 0xd5, 0x68, 0xaa, 0xb5, 0x8e,
	0x94, 0x42, 0x39, 0x48, 0xef, 0x1d, 0xb5, 0x4f, 0xa5, 0x34, 0xe5, 0xab, 0xad, 0x8e, 0x82, 0x5b,
	0xbb, 0x4d, 0x29, 0x23, 0x97, 0x41, 0x54, 0x0d, 0x84, 0x20, 0x3d, 0xd4, 0x07, 0x84, 0xd9, 0x9e,
	0xc7, 0xec, 0x1b, 0x2d, 0x82, 0x68, 0x1a, 0x81, 0x55, 0xa2, 0x69, 0xc8, 0xaf, 0x45, 0xc8, 0xd5,
	0x75, 0x4f, 0xef, 0xe9, 0x2e, 0x41, 0xb7, 0xd8, 0x22, 0x15, 0x2f, 0x54, 0x17, 0x38, 0x57, 0x55,
	0x83, 0xca, 0xa2, 0x35, 0xc8, 0xba, 0xe4, 0x49, 0x37, 0xd8, 0x9f, 0xc6, 0x19, 0x97, 0x3c, 0x51,
	0x0d, 0x54, 0x82, 0x9c, 0x65, 0xf7, 0x59, 0x24, 0x03, 0xbf, 0x26, 0x34, 0xaa, 0x01, 0x8c, 0x74,
	0x47, 0x1f, 0x10, 0x8f, 0x38, 0x6e, 0x31, 0xbd, 0x99, 0x2a, 0x17, 0xaa, 0x1f, 0x72, 0xc8, 0xa1,
	0xea, 0x9d, 0xc3, 0x89, 0x94, 0x32, 0xf4, 0x9c, 0x0b, 0xcc, 0x6d, 0x43, 0xc7, 0xb0, 0xec, 0x5e,
	0xb8, 0x1e, 0x19, 0x74, 0x39, 0xac, 0x0c, 0xc3, 0xfa, 0x24, 0x09, 0xab, 0xcd, 0x84, 0xa7, 0x11,
	0x25, 0x77, 0x8a, 0x5d, 0xfa, 0x12, 0x96, 0xa6, 0x84, 0x90, 0x04, 0xa9, 0x73, 0x72, 0x11, 0x44,
	0x8c, 0x7e, 0xd2, 0x4c, 0x3e, 0xd5, 0xad, 0x31, 0x09, 0x33, 0xc9, 0x88, 0xcf, 0xc4, 0xfb, 0x42,
	0xa9, 0x06, 0x6b, 0x89, 0x9a, 0xde, 0x06, 0x44, 0x7e, 0x0e, 0x6b, 0x35, 0x87, 0xe8, 0x1e, 0x09,
	0xad, 0x0f, 0xca, 0x0a, 0x15, 0x61, 0xae, 0xaf, 0x7b, 0xba, 0x65, 0x9f, 0x05, 0x40, 0x21, 0x89,
	0x2a, 0x90, 0x33, 0x02, 0x61, 0x86, 0x57, 0xa8, 0xae, 0x24, 0x44, 0x01, 0x4f, 0x84, 0x66, 0x96,
	0x1d, 0x01, 0xb4, 0x4f, 0xbc, 0x37, 0x57, 0x7c, 0x6b, 0x52, 0x3b, 0x89, 0xe5, 0x31, 0x4b, 0xcd,
	0x33, 0x58, 0x89, 0xa9, 0x71, 0x47, 0xf6, 0xd0, 0x25, 0x31, 0x37, 0x84, 0x37, 0x71, 0xe3, 0xee,
	0xe4, 0x30, 0xfa, 0x26, 0x14, 0x67, 0x1d, 0xc6, 0xf0, 0x14, 0xca, 0xaf, 0x04, 0x58, 0x6d, 0x9a,
	0xee, 0x44, 0xb7, 0x7b, 0xbd, 0x8f, 0x91, 0x13, 0x22, 0xef, 0x04, 0xfa, 0x00, 0xe6, 0xe9, 0xf9,
	0xe9, 0x8e, 0x74, 0xcf, 0x23, 0x4e, 0x58, 0xe8, 0x05, 0xca, 0x3b, 0xf4, 0x59, 0xe8, 0x63, 0x58,
	0x24, 0xcf, 0xfa, 0xd6, 0xd8, 0x20, 0x7e, 0x9d, 0xd2, 0x7a, 0x17, 0xca, 0x39, 0xbc, 0x10, 0x70,
	0x59, 0x99, 0xb8, 0xf2, 0x63, 0x58, 0xa9, 0x3b, 0xf6, 0xe8, 0x5f, 0x0f, 0xbb, 0x06, 0x85, 0x86,
	0x49, 0x2c, 0xa3, 0xdd, 0xff, 0x8e, 0x0c, 0xf4, 0xc4, 0x66, 0x80, 0x20, 0xed, 0x5d, 0x8c, 0x42,
	0x57, 0xd9, 0x37, 0xb3, 0xc3, 0x1e, 0x0c, 0xc8, 0xd0, 0x0b, 0xf0, 0x42, 0x52, 0xfe, 0x4b, 0x80,
	0x7c, 0x9b, 0x38, 0x75, 0xa2, 0x0e, 0x1f, 0xdb, 0xa8, 0x1c, 0xec, 0xf5, 0x1b, 0xe3, 0x2a, 0x67,
	0x57, 0x9b, 0x38, 0x06, 0xe9, 0x5c, 0x8c, 0x48, 0x80, 0x18, 0x6a, 0x16, 0x39, 0xcd, 0x5b, 0x20,
	0xb9, 0xc4, 0x31, 0x75, 0xcb, 0x7c, 0xce, 0x1a, 0x45, 0xd3, 0xec, 0x05, 0xea, 0x2e, 0xf1, 0x51,
	0x3d, 0xa1, 0x87, 0x7c, 0x14, 0xd7, 0xe7, 0xdb, 0x74, 0x55, 0x13, 0xf9, 0x87, 0x87, 0x5d, 0xbe,
	0x07, 0x19, 0xcd, 0x31, 0x88, 0x43, 0x37, 0xf5, 0x6d, 0x2b, 0xdc, 0xd4, 0xb7, 0x2d, 0xb4, 0x01,
	0x79, 0xdd, 0xed, 0x93, 0xa1, 0x61, 0x0e, 0xcf, 0xd8, 0xc6, 0x1c, 0x8e, 0x18, 0xf2, 0xeb, 0x0c,
	0x2c, 0xb7, 0x3d, 0xdb, 0xd1, 0xcf, 0x48, 0x9d, 0xb8, 0x7d, 0xc7, 0x1c, 0x79, 0xb6, 0x83, 0xb6,
	0x20, 0xdd, 0xb7, 0x2d, 0x7a, 0xad, 0x50, 0x6f, 0xd6, 0x39, 0x6f, 0xb8, 0x9c, 0x61, 0x26, 0x13,
	0xeb, 0xaf, 0xe2, 0x54, 0x7f, 0xbd, 0x0f, 0x05, 0x73, 0x38, 0x1a, 0x7b, 0x0d, 0xdb, 0x19, 0xe8,
	0x7e, 0xc6, 0x16, 0x63, 0x70, 0x6a, 0xb4, 0x8a, 0x79, 0x51, 0x54, 0x86, 0x25, 0x8e, 0x6c, 0xd1,
	0x04, 0xa5, 0x19, 0xf8, 0x34, 0x1b, 0x7d, 0x0e, 0xf3, 0xf6, 0xd8, 0x8b, 0x94, 0x64, 0x98, 0x92,
	0xff, 0x71, 0x4a, 0x34, 0x6e, 0x19, 0xc7, 0x84, 0x69, 0xa2, 0x79, 0x9a, 0xe9, 0xc9, 0xfa, 0x89,
	0x9e, 0xe6, 0xa3, 0xdb, 0x00, 0xc3, 0xf1, 0x60, 0x6f, 0xdc, 0x3f, 0x27, 0x9e, 0x5b, 0x9c, 0xdb,
	0x14, 0xca, 0x19, 0xcc, 0x71, 0x50, 0x15, 0xf2, 0x2e, 0xad, 0x2d, 0x9a, 0xeb, 0x62, 0x8e, 0x9d,
	0x87, 0xd5, 0xa4, 0x3a, 0xc0, 0x91, 0x18, 0xc5, 0xec, 0xb1, 0xed, 0x35, 0x1a, 0xee, 0xfc, 0x66,
	0xaa, 0x9c, 0xc7, 0x1c, 0x07, 0x6d, 0x43, 0xce, 0xb5, 0x1d, 0x7f, 0x15, 0x58, 0x32, 0x24, 0xde,
	0x31, 0x9a, 0x72, 0x3c, 0x91, 0x40, 0xcd, 0x58, 0x29, 0x16, 0x98, 0xfc, 0x36, 0x6f, 0xc2, 0x74,
	0xa2, 0xaf, 0xbc, 0xd7, 0xba, 0x49, 0xf7, 0xda, 0x3c, 0x03, 0xad, 0x5e, 0x09, 0xfa, 0x3e, 0x5d,
	0x70, 0x7f, 0xa6, 0x20, 0xd3, 0xd1, 0x7b, 0xd6, 0x5b, 0x4c, 0x17, 0x29, 0x7e, 0xba, 0xd8, 0x06,
	0xd1, 0x35, 0x58, 0x69, 0x16, 0xaa, 0x1b, 0x57, 0x45, 0x05, 0x8b, 0xae, 0x81, 0xbe, 0x80, 0x85,
	0x91, 0xee, 0x78, 0x26, 0x3d, 0x1c, 0x0f, 0xc9, 0x45, 0x38, 0x26, 0xcc, 0x3a, 0x60, 0x71, 0x61,
	0x5a, 0x60, 0x1e, 0x35, 0x95, 0x36, 0x2f, 0x56, 0xa5, 0xf1, 0xc6, 0xd6, 0x09, 0xd7, 0x70, 0x24,
	0x86, 0xbe, 0x8e, 0x95, 0xc4, 0x1c, 0x53, 0xb7, 0x39, 0xbd, 0xe9, 0xca, 0x32, 0x68, 0x27, 0x95,
	0x41, 0x8e, 0x01, 0xdd, 0xb9, 0x04, 0xf4, 0x3e, 0xa5, 0xfe, 0x95, 0x00, 0xc8, 0x1f, 0x6e, 0x98,
	0xed, 0xd7, 0xdf, 0x74, 0x32, 0x64, 0x8c, 0x5e, 0x77, 0xd6, 0x65, 0x97, 0x36, 0x7a, 0xaa, 0x81,
	0xee, 0x40, 0x86, 0x05, 0x9f, 0x55, 0x49, 0xfc, 0xb4, 0xfa, 0x5a, 0xfc, 0x65, 0xee, 0x5a, 0x4c,
	0xc7, 0xae, 0xc5, 0x1f, 0x05, 0x58, 0xda, 0x27, 0xde, 0x3b, 0xb4, 0xc8, 0xaf, 0xeb, 0xd4, 0xf5,
	0xf7, 0x73, 0xdc, 0x10, 0x0b, 0xa4, 0xc8, 0x8e, 0x60, 0x26, 0x9a, 0x38, 0x27, 0x5c, 0xed, 0xdc,
	0xdb, 0x8f, 0x42, 0x26, 0x2c, 0xd3, 0x49, 0x88, 0xa1, 0xb8, 0xef, 0xc6, 0xef, 0x59, 0x83, 0xc7,
	0x4f, 0x02, 0x48, 0x74, 0xc2, 0xf9, 0xcf, 0x43, 0xbc, 0xf5, 0x8b, 0x3f, 0xb1, 0xf8, 0xd3, 0x08,
	0x92, 0x60, 0xbe, 0xad, 0xe0, 0xba, 0xd2, 0xad, 0x1d, 0xb5, 0x3b, 0xda, 0x81, 0x74, 0x03, 0xad,
	0xc1, 0xb2, 0xcf, 0x69, 0xee, 0x7e, 0x7b, 0xda, 0x6d, 0xab, 0x07, 0x87, 0x4d, 0x45, 0x12, 0xd0,
	0x22, 0x80, 0xcf, 0xde, 0x3d, 0xc6, 0x9a, 0x24, 0x46, 0xf4, 0x37, 0x6d, 0xad, 0x25, 0xa5, 0xd0,
	0x02, 0xe4, 0x7d, 0x5a, 0xc3, 0x35, 0x29, 0x8d, 0x96, 0xa0, 0xe0, 0x93, 0x58, 0xd9, 0x57, 0x4e,
	0xa4, 0x4c, 0xa4, 0xa8, 0xf3, 0x00, 0xab, 0x8d, 0x8e, 0x94, 0x45, 0xcb, 0xb0, 0xe0, 0x73, 0x0e,
	0x77, 0xf1, 0xa3, 0x23, 0xa5, 0x23, 0xcd, 0x45, 0x20, 0xb5, 0xf6, 0xb1, 0x94, 0xdb, 0xda, 0x87,
	0x02, 0x77, 0x55, 0xd3, 0x55, 0xb5, 0x11, 0x19, 0xba, 0x04, 0x05, 0xb5, 0xd1, 0x6d, 0x2b, 0x8f,
	0x8e, 0x94, 0x56, 0x8d, 0x9a, 0x58, 0x80, 0x39, 0xb5, 0xd1, 0xed, 0x28, 0x27, 0x1d, 0x49, 0x0c,
	0x88, 0x07, 0xea, 0xb1, 0x22, 0xa5, 0xb6, 0x5a, 0x30, 0xcf, 0x5f, 0xc7, 0x14, 0x49, 0x8b, 0x23,
	0x69, 0x1c, 0x92, 0x48, 0x4d, 0xd3, 0x1a, 0x5d, 0x75, 0xbf, 0xa5, 0x61, 0xa5, 0xfb, 0x50, 0x39,
	0x95, 0x52, 0x14, 0x4f, 0x0b, 0xf0, 0xd2, 0x5b, 0x35, 0xc8, 0x4f, 0xfa, 0x1e, 0x15, 0xee, 0x74,
	0x4e, 0x0f, 0x95, 0xee, 0xc1, 0x6e, 0x6b, 0x77, 0x5f, 0xa9, 0x4b, 0x37, 0x10, 0x82, 0x45, 0x9f,
	0xa5, 0x9c, 0x04, 0xcf, 0x4f, 0x81, 0x2a, 0xf1, 0x79, 0x6a, 0xab, 0xae, 0x9c, 0x48, 0x62, 0xf5,
	0xd7, 0x0c, 0xe4, 0x0f, 0xc2, 0xac, 0x21, 0x0c, 0x8b, 0xe1, 0x9b, 0xa7, 0xa7, 0x7b, 0x74, 0xb4,
	0xe7, 0x1b, 0x66, 0xe2, 0x73, 0xa8, 0x74, 0x9b, 0x93, 0x48, 0x7a, 0x4d, 0x58, 0x50, 0xe0, 0xd8,
	0xe8, 0xd6, 0x2c, 0xf1, 0x37, 0x42, 0x93, 0x6f, 0xff, 0xf0, 0xfb, 0x1f, 0x3f, 0x8b, 0x45, 0xb4,
	0x5e, 0x79, 0x5a, 0xad, 0x84, 0x0f, 0x90, 0xca, 0x8b, 0xa0, 0x64, 0x5f, 0x22, 0x02, 0x0b, 0xb1,
	0x77, 0x05, 0xe2, 0xff, 0x18, 0x48, 0x7a, 0x71, 0x94, 0x92, 0xde, 0x36, 0xf2, 0x06, 0x53, 0xb3,
	0x8e, 0x56, 0x99, 0x9a, 0x9e, 0x65, 0xba, 0x5e, 0xa4, 0xe4, 0xae, 0x80, 0x1e, 0xc0, 0x3c, 0xff,
	0x54, 0x40, 0xbc, 0xd9, 0x09, 0x6f, 0x88, 0xd2, 0xcc, 0x36, 0x80, 0x54, 0x28, 0x70, 0x9d, 0x38,
	0x16, 0x9e, 0xcb, 0x1d, 0xba, 0x74, 0x33, 0x1e, 0x9e, 0x78, 0x8f, 0xfa, 0x1e, 0x72, 0x21, 0x0f,
	0x95, 0x12, 0x05, 0xaf, 0x07, 0x91, 0xab, 0xcc, 0xf3, 0x6d, 0xb4, 0x45, 0x3d, 0x67, 0x3d, 0x2d,
	0x72, 0xbc, 0xf2, 0x82, 0xf5, 0x83, 0x1d, 0xfa, 0x50, 0x78, 0x59, 0x79, 0x11, 0x7e, 0xa1, 0xaf,
	0x00, 0xa2, 0x16, 0x86, 0x36, 0xa6, 0x22, 0x1e, 0xeb, 0x6c, 0xa5, 0x4b, 0x9d, 0xf3, 0xae, 0x80,
	0xf6, 0x20, 0x3f, 0x69, 0x4b, 0xe8, 0xe6, 0x54, 0x28, 0x63, 0xa6, 0xcf, 0x8c, 0xe3, 0x9e, 0x0c,
	0x2b, 0x7d, 0x7b, 0xb0, 0xa3, 0x9f, 0xdb, 0x56, 0x2f, 0x12, 0xda, 0x63, 0xc5, 0x4d, 0x27, 0x12,
	0x72, 0x28, 0xf4, 0xb2, 0xec, 0xdf, 0xa4, 0x4f, 0xff, 0x0e, 0x00, 0x00, 0xff, 0xff, 0xd9, 0x41,
	0xf5, 0x7d, 0x89, 0x12, 0x00, 0x00,
}
