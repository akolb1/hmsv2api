// Code generated by protoc-gen-go. DO NOT EDIT.
// source: protobuf/metastore.proto

/*
Package metastore is a generated protocol buffer package.

It is generated from these files:
	protobuf/metastore.proto

It has these top-level messages:
	RequestStatus
	Namespace
	Cookie
	Id
	Database
	CreateDatabaseRequest
	GetDatabaseRequest
	GetDatabaseResponse
	ListDatabasesRequest
	DropDatabaseRequest
*/
package metastore

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type RequestStatus_Status int32

const (
	RequestStatus_OK       RequestStatus_Status = 0
	RequestStatus_ERROR    RequestStatus_Status = 1
	RequestStatus_NOTFOUND RequestStatus_Status = 2
	RequestStatus_CONFLICT RequestStatus_Status = 3
)

var RequestStatus_Status_name = map[int32]string{
	0: "OK",
	1: "ERROR",
	2: "NOTFOUND",
	3: "CONFLICT",
}
var RequestStatus_Status_value = map[string]int32{
	"OK":       0,
	"ERROR":    1,
	"NOTFOUND": 2,
	"CONFLICT": 3,
}

func (x RequestStatus_Status) String() string {
	return proto.EnumName(RequestStatus_Status_name, int32(x))
}
func (RequestStatus_Status) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

// General status for results
type RequestStatus struct {
	Status RequestStatus_Status `protobuf:"varint,1,opt,name=status,enum=metastore.RequestStatus_Status" json:"status,omitempty"`
	Error  string               `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
	Cookie *Cookie              `protobuf:"bytes,3,opt,name=cookie" json:"cookie,omitempty"`
}

func (m *RequestStatus) Reset()                    { *m = RequestStatus{} }
func (m *RequestStatus) String() string            { return proto.CompactTextString(m) }
func (*RequestStatus) ProtoMessage()               {}
func (*RequestStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *RequestStatus) GetStatus() RequestStatus_Status {
	if m != nil {
		return m.Status
	}
	return RequestStatus_OK
}

func (m *RequestStatus) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *RequestStatus) GetCookie() *Cookie {
	if m != nil {
		return m.Cookie
	}
	return nil
}

// Every object belongs to a namespace. The idea is that operations across
// namespaces are completely independent. They can be forwarded to different storage
// engines.
// Namespase is created automatically when an object is placed in a namespace.
// NOTE - should we explicitely manage namespaces instead?
type Namespace struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *Namespace) Reset()                    { *m = Namespace{} }
func (m *Namespace) String() string            { return proto.CompactTextString(m) }
func (*Namespace) ProtoMessage()               {}
func (*Namespace) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Namespace) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Cookie is supposed to be used to associate multiple requests to a single session.
// The value of the cookie is likely to be printed in logs so it shouldn't contain
// any sensitive information.
// Metastore service does not interpret the cookie but may print it in its logs.
// We could call it SessionId but callers may decide to use it for whatever other
// purposes, so using generic term here.
type Cookie struct {
	Cookie string `protobuf:"bytes,1,opt,name=cookie" json:"cookie,omitempty"`
}

func (m *Cookie) Reset()                    { *m = Cookie{} }
func (m *Cookie) String() string            { return proto.CompactTextString(m) }
func (*Cookie) ProtoMessage()               {}
func (*Cookie) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Cookie) GetCookie() string {
	if m != nil {
		return m.Cookie
	}
	return ""
}

// Objects belong to a specific namespace and have unique name and unique ID
// in the namespace.
type Id struct {
	Namespace *Namespace `protobuf:"bytes,1,opt,name=namespace" json:"namespace,omitempty"`
	Name      string     `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Id        string     `protobuf:"bytes,3,opt,name=id" json:"id,omitempty"`
}

func (m *Id) Reset()                    { *m = Id{} }
func (m *Id) String() string            { return proto.CompactTextString(m) }
func (*Id) ProtoMessage()               {}
func (*Id) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Id) GetNamespace() *Namespace {
	if m != nil {
		return m.Namespace
	}
	return nil
}

func (m *Id) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Id) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// Database is a container for tables.
// Original Metastore Database object also had location and owner information.
// These can be represented using parameters if needed since the current
// metastore service does n;t interpret either Location or Owner info.
type Database struct {
	Id         *Id               `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Parameters map[string]string `protobuf:"bytes,2,rep,name=parameters" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Database) Reset()                    { *m = Database{} }
func (m *Database) String() string            { return proto.CompactTextString(m) }
func (*Database) ProtoMessage()               {}
func (*Database) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Database) GetId() *Id {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Database) GetParameters() map[string]string {
	if m != nil {
		return m.Parameters
	}
	return nil
}

// Create a new database.
type CreateDatabaseRequest struct {
	Database *Database `protobuf:"bytes,1,opt,name=database" json:"database,omitempty"`
	Cookie   *Cookie   `protobuf:"bytes,2,opt,name=cookie" json:"cookie,omitempty"`
}

func (m *CreateDatabaseRequest) Reset()                    { *m = CreateDatabaseRequest{} }
func (m *CreateDatabaseRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateDatabaseRequest) ProtoMessage()               {}
func (*CreateDatabaseRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *CreateDatabaseRequest) GetDatabase() *Database {
	if m != nil {
		return m.Database
	}
	return nil
}

func (m *CreateDatabaseRequest) GetCookie() *Cookie {
	if m != nil {
		return m.Cookie
	}
	return nil
}

// Request to get database by its ID.
type GetDatabaseRequest struct {
	Id     *Id     `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Cookie *Cookie `protobuf:"bytes,2,opt,name=cookie" json:"cookie,omitempty"`
}

func (m *GetDatabaseRequest) Reset()                    { *m = GetDatabaseRequest{} }
func (m *GetDatabaseRequest) String() string            { return proto.CompactTextString(m) }
func (*GetDatabaseRequest) ProtoMessage()               {}
func (*GetDatabaseRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *GetDatabaseRequest) GetId() *Id {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *GetDatabaseRequest) GetCookie() *Cookie {
	if m != nil {
		return m.Cookie
	}
	return nil
}

type GetDatabaseResponse struct {
	Database *Database      `protobuf:"bytes,1,opt,name=database" json:"database,omitempty"`
	Status   *RequestStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *GetDatabaseResponse) Reset()                    { *m = GetDatabaseResponse{} }
func (m *GetDatabaseResponse) String() string            { return proto.CompactTextString(m) }
func (*GetDatabaseResponse) ProtoMessage()               {}
func (*GetDatabaseResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *GetDatabaseResponse) GetDatabase() *Database {
	if m != nil {
		return m.Database
	}
	return nil
}

func (m *GetDatabaseResponse) GetStatus() *RequestStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// Request to get list of databases
type ListDatabasesRequest struct {
	Namespace   *Namespace `protobuf:"bytes,1,opt,name=namespace" json:"namespace,omitempty"`
	Cookie      *Cookie    `protobuf:"bytes,2,opt,name=cookie" json:"cookie,omitempty"`
	NamePattern string     `protobuf:"bytes,3,opt,name=name_pattern,json=namePattern" json:"name_pattern,omitempty"`
}

func (m *ListDatabasesRequest) Reset()                    { *m = ListDatabasesRequest{} }
func (m *ListDatabasesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListDatabasesRequest) ProtoMessage()               {}
func (*ListDatabasesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *ListDatabasesRequest) GetNamespace() *Namespace {
	if m != nil {
		return m.Namespace
	}
	return nil
}

func (m *ListDatabasesRequest) GetCookie() *Cookie {
	if m != nil {
		return m.Cookie
	}
	return nil
}

func (m *ListDatabasesRequest) GetNamePattern() string {
	if m != nil {
		return m.NamePattern
	}
	return ""
}

// Request to drop a database.
// Dropping a database also drops all objects contained in the database
type DropDatabaseRequest struct {
	Id     *Id     `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Cookie *Cookie `protobuf:"bytes,2,opt,name=cookie" json:"cookie,omitempty"`
}

func (m *DropDatabaseRequest) Reset()                    { *m = DropDatabaseRequest{} }
func (m *DropDatabaseRequest) String() string            { return proto.CompactTextString(m) }
func (*DropDatabaseRequest) ProtoMessage()               {}
func (*DropDatabaseRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *DropDatabaseRequest) GetId() *Id {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *DropDatabaseRequest) GetCookie() *Cookie {
	if m != nil {
		return m.Cookie
	}
	return nil
}

func init() {
	proto.RegisterType((*RequestStatus)(nil), "metastore.RequestStatus")
	proto.RegisterType((*Namespace)(nil), "metastore.Namespace")
	proto.RegisterType((*Cookie)(nil), "metastore.Cookie")
	proto.RegisterType((*Id)(nil), "metastore.Id")
	proto.RegisterType((*Database)(nil), "metastore.Database")
	proto.RegisterType((*CreateDatabaseRequest)(nil), "metastore.CreateDatabaseRequest")
	proto.RegisterType((*GetDatabaseRequest)(nil), "metastore.GetDatabaseRequest")
	proto.RegisterType((*GetDatabaseResponse)(nil), "metastore.GetDatabaseResponse")
	proto.RegisterType((*ListDatabasesRequest)(nil), "metastore.ListDatabasesRequest")
	proto.RegisterType((*DropDatabaseRequest)(nil), "metastore.DropDatabaseRequest")
	proto.RegisterEnum("metastore.RequestStatus_Status", RequestStatus_Status_name, RequestStatus_Status_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Metastore service

type MetastoreClient interface {
	// Create a new database
	CreateDabatase(ctx context.Context, in *CreateDatabaseRequest, opts ...grpc.CallOption) (*GetDatabaseResponse, error)
	// Get database information
	GetDatabase(ctx context.Context, in *GetDatabaseRequest, opts ...grpc.CallOption) (*GetDatabaseResponse, error)
	// Get collection of databases
	ListDatabases(ctx context.Context, in *ListDatabasesRequest, opts ...grpc.CallOption) (Metastore_ListDatabasesClient, error)
	// Destroy a database
	DropDatabase(ctx context.Context, in *DropDatabaseRequest, opts ...grpc.CallOption) (*RequestStatus, error)
}

type metastoreClient struct {
	cc *grpc.ClientConn
}

func NewMetastoreClient(cc *grpc.ClientConn) MetastoreClient {
	return &metastoreClient{cc}
}

func (c *metastoreClient) CreateDabatase(ctx context.Context, in *CreateDatabaseRequest, opts ...grpc.CallOption) (*GetDatabaseResponse, error) {
	out := new(GetDatabaseResponse)
	err := grpc.Invoke(ctx, "/metastore.Metastore/CreateDabatase", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metastoreClient) GetDatabase(ctx context.Context, in *GetDatabaseRequest, opts ...grpc.CallOption) (*GetDatabaseResponse, error) {
	out := new(GetDatabaseResponse)
	err := grpc.Invoke(ctx, "/metastore.Metastore/GetDatabase", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metastoreClient) ListDatabases(ctx context.Context, in *ListDatabasesRequest, opts ...grpc.CallOption) (Metastore_ListDatabasesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Metastore_serviceDesc.Streams[0], c.cc, "/metastore.Metastore/ListDatabases", opts...)
	if err != nil {
		return nil, err
	}
	x := &metastoreListDatabasesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Metastore_ListDatabasesClient interface {
	Recv() (*Database, error)
	grpc.ClientStream
}

type metastoreListDatabasesClient struct {
	grpc.ClientStream
}

func (x *metastoreListDatabasesClient) Recv() (*Database, error) {
	m := new(Database)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *metastoreClient) DropDatabase(ctx context.Context, in *DropDatabaseRequest, opts ...grpc.CallOption) (*RequestStatus, error) {
	out := new(RequestStatus)
	err := grpc.Invoke(ctx, "/metastore.Metastore/DropDatabase", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Metastore service

type MetastoreServer interface {
	// Create a new database
	CreateDabatase(context.Context, *CreateDatabaseRequest) (*GetDatabaseResponse, error)
	// Get database information
	GetDatabase(context.Context, *GetDatabaseRequest) (*GetDatabaseResponse, error)
	// Get collection of databases
	ListDatabases(*ListDatabasesRequest, Metastore_ListDatabasesServer) error
	// Destroy a database
	DropDatabase(context.Context, *DropDatabaseRequest) (*RequestStatus, error)
}

func RegisterMetastoreServer(s *grpc.Server, srv MetastoreServer) {
	s.RegisterService(&_Metastore_serviceDesc, srv)
}

func _Metastore_CreateDabatase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDatabaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetastoreServer).CreateDabatase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/metastore.Metastore/CreateDabatase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetastoreServer).CreateDabatase(ctx, req.(*CreateDatabaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Metastore_GetDatabase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDatabaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetastoreServer).GetDatabase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/metastore.Metastore/GetDatabase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetastoreServer).GetDatabase(ctx, req.(*GetDatabaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Metastore_ListDatabases_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListDatabasesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MetastoreServer).ListDatabases(m, &metastoreListDatabasesServer{stream})
}

type Metastore_ListDatabasesServer interface {
	Send(*Database) error
	grpc.ServerStream
}

type metastoreListDatabasesServer struct {
	grpc.ServerStream
}

func (x *metastoreListDatabasesServer) Send(m *Database) error {
	return x.ServerStream.SendMsg(m)
}

func _Metastore_DropDatabase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DropDatabaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetastoreServer).DropDatabase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/metastore.Metastore/DropDatabase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetastoreServer).DropDatabase(ctx, req.(*DropDatabaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Metastore_serviceDesc = grpc.ServiceDesc{
	ServiceName: "metastore.Metastore",
	HandlerType: (*MetastoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateDabatase",
			Handler:    _Metastore_CreateDabatase_Handler,
		},
		{
			MethodName: "GetDatabase",
			Handler:    _Metastore_GetDatabase_Handler,
		},
		{
			MethodName: "DropDatabase",
			Handler:    _Metastore_DropDatabase_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListDatabases",
			Handler:       _Metastore_ListDatabases_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "protobuf/metastore.proto",
}

func init() { proto.RegisterFile("protobuf/metastore.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 563 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x54, 0xdf, 0x6e, 0x12, 0x4f,
	0x14, 0xfe, 0xcd, 0xf0, 0xeb, 0xa6, 0x7b, 0x28, 0x88, 0x07, 0x34, 0x1b, 0x92, 0xda, 0x75, 0xbd,
	0xc1, 0x1b, 0xda, 0xac, 0x17, 0x35, 0x26, 0xde, 0x14, 0xda, 0x4a, 0x44, 0x20, 0xd3, 0x7a, 0x67,
	0x6c, 0x06, 0x18, 0x13, 0x42, 0x61, 0xd7, 0x99, 0xc1, 0xd8, 0x37, 0xf1, 0x25, 0x7c, 0x07, 0xe3,
	0x93, 0x99, 0xfd, 0xcb, 0xd0, 0x2c, 0x69, 0x6b, 0xe2, 0xd5, 0xce, 0x9c, 0xf3, 0x9d, 0xef, 0x3b,
	0xff, 0x66, 0xc1, 0x09, 0x65, 0xa0, 0x83, 0xf1, 0xea, 0xcb, 0xe1, 0x42, 0x68, 0xae, 0x74, 0x20,
	0x45, 0x3b, 0x36, 0xa1, 0x9d, 0x1b, 0xbc, 0xdf, 0x04, 0x2a, 0x4c, 0x7c, 0x5d, 0x09, 0xa5, 0x2f,
	0x34, 0xd7, 0x2b, 0x85, 0xc7, 0x60, 0xa9, 0xf8, 0xe4, 0x10, 0x97, 0xb4, 0xaa, 0xfe, 0x41, 0x7b,
	0x1d, 0xbe, 0x81, 0x6c, 0x27, 0x1f, 0x96, 0xc2, 0xb1, 0x01, 0x3b, 0x42, 0xca, 0x40, 0x3a, 0xd4,
	0x25, 0x2d, 0x9b, 0x25, 0x17, 0x7c, 0x09, 0xd6, 0x24, 0x08, 0xe6, 0x33, 0xe1, 0x94, 0x5c, 0xd2,
	0x2a, 0xfb, 0x8f, 0x0d, 0xba, 0x4e, 0xec, 0x60, 0x29, 0xc0, 0x3b, 0x06, 0x2b, 0xcd, 0xc1, 0x02,
	0x3a, 0x7c, 0x5f, 0xfb, 0x0f, 0x6d, 0xd8, 0x39, 0x65, 0x6c, 0xc8, 0x6a, 0x04, 0xf7, 0x60, 0x77,
	0x30, 0xbc, 0x3c, 0x1b, 0x7e, 0x1c, 0x74, 0x6b, 0x34, 0xba, 0x75, 0x86, 0x83, 0xb3, 0x7e, 0xaf,
	0x73, 0x59, 0x2b, 0x79, 0x07, 0x60, 0x0f, 0xf8, 0x42, 0xa8, 0x90, 0x4f, 0x04, 0x22, 0xfc, 0xbf,
	0xe4, 0x0b, 0x11, 0x67, 0x6f, 0xb3, 0xf8, 0xec, 0xb9, 0x60, 0x25, 0x5a, 0xf8, 0x34, 0x4f, 0x27,
	0xf1, 0x67, 0xda, 0x9f, 0x80, 0xf6, 0xa6, 0xe8, 0x83, 0xbd, 0xcc, 0x88, 0x62, 0x40, 0xd9, 0x6f,
	0x18, 0xf9, 0xe6, 0x22, 0x6c, 0x0d, 0xcb, 0xf5, 0xe8, 0x5a, 0x0f, 0xab, 0x40, 0x67, 0xd3, 0xb8,
	0x60, 0x9b, 0xd1, 0xd9, 0xd4, 0xfb, 0x49, 0x60, 0xb7, 0xcb, 0x35, 0x1f, 0x73, 0x25, 0x70, 0x3f,
	0x76, 0x26, 0xec, 0x15, 0x83, 0xbd, 0x37, 0x8d, 0xb0, 0xd8, 0x01, 0x08, 0xb9, 0xe4, 0x0b, 0xa1,
	0x85, 0x54, 0x0e, 0x75, 0x4b, 0xad, 0xb2, 0xff, 0xc2, 0x80, 0x65, 0x3c, 0xed, 0x51, 0x8e, 0x3a,
	0x5d, 0x6a, 0x79, 0xc3, 0x8c, 0xb0, 0xe6, 0x5b, 0x78, 0x74, 0xcb, 0x8d, 0x35, 0x28, 0xcd, 0xc5,
	0x4d, 0x5a, 0x76, 0x74, 0x8c, 0x06, 0xf6, 0x8d, 0x5f, 0xaf, 0xb2, 0xd4, 0x93, 0xcb, 0x1b, 0xfa,
	0x9a, 0x78, 0x0a, 0x9e, 0x74, 0xa4, 0xe0, 0x5a, 0x64, 0x62, 0xe9, 0xe0, 0xf1, 0x10, 0x76, 0xa7,
	0xa9, 0x29, 0xad, 0xa0, 0x5e, 0x90, 0x1a, 0xcb, 0x41, 0xc6, 0xf8, 0xe9, 0x5d, 0xe3, 0xff, 0x0c,
	0x78, 0x2e, 0xf4, 0x6d, 0xc5, 0x3b, 0xba, 0xf5, 0x00, 0xfe, 0xef, 0x50, 0xdf, 0xe0, 0x57, 0x61,
	0xb0, 0x54, 0xe2, 0xe1, 0x25, 0x1d, 0xe5, 0x0f, 0x24, 0x91, 0x74, 0xb6, 0x3d, 0x90, 0xec, 0x65,
	0x78, 0x3f, 0x08, 0x34, 0xfa, 0x33, 0x95, 0x6b, 0xab, 0xac, 0xb8, 0xbf, 0xd9, 0xb7, 0xfb, 0x57,
	0x8c, 0xcf, 0x61, 0x2f, 0x8a, 0xbb, 0x0a, 0xb9, 0xd6, 0x42, 0x2e, 0xd3, 0x85, 0x2c, 0x47, 0xb6,
	0x51, 0x62, 0xf2, 0xae, 0xa0, 0xde, 0x95, 0x41, 0xf8, 0xcf, 0xba, 0xee, 0xff, 0xa2, 0x60, 0x7f,
	0xc8, 0x9c, 0xc8, 0xa0, 0x9a, 0x2d, 0xd6, 0x98, 0xeb, 0xa8, 0x9b, 0xae, 0x19, 0x5a, 0xb4, 0x73,
	0xcd, 0x67, 0x06, 0xa2, 0x68, 0x80, 0x7d, 0x28, 0x1b, 0x66, 0xdc, 0xdf, 0x06, 0xbf, 0x1f, 0xdb,
	0x39, 0x54, 0x36, 0x46, 0x85, 0xe6, 0xff, 0xaf, 0x68, 0x88, 0xcd, 0xa2, 0x75, 0x39, 0x22, 0xf8,
	0x0e, 0xf6, 0xcc, 0xce, 0xa2, 0x29, 0x5c, 0xd0, 0xf2, 0xe6, 0xd6, 0x35, 0x3a, 0xf1, 0xa0, 0x3e,
	0x09, 0x16, 0x6d, 0x3e, 0x0f, 0xae, 0xc7, 0x6b, 0xd0, 0x49, 0xdc, 0xd6, 0x8b, 0xe8, 0x38, 0x22,
	0x63, 0x2b, 0xfe, 0xb3, 0xbf, 0xfa, 0x13, 0x00, 0x00, 0xff, 0xff, 0x2c, 0x1d, 0x6c, 0xae, 0xf5,
	0x05, 0x00, 0x00,
}
